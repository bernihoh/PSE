\documentclass{article}

\usepackage[margin=2.5cm]{geometry}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}

\usepackage{hyperref}
\hypersetup{
pdftitle={Pflichtenheft},
bookmarks = true
}
\usepackage[toc]{glossaries}

\usepackage{graphicx}

\usepackage[shortlabels]{enumitem}
\usepackage{parskip}

\usepackage{float}
\floatplacement{figure}{H}
\usepackage{placeins}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{fix-cm}
\newcommand{\titlesize}{\fontsize{30pt}{20pt}\selectfont}
\newcommand{\themesize}{\fontsize{20pt}{20pt}\selectfont}
\newcommand{\authorsize}{\fontsize{15pt}{20pt}\selectfont}

\newcommand{\mypackage}[1]{\subsection*{Package #1} \label{#1} \addcontentsline{toc}{subsection}{\nameref{#1}}}
\newcommand{\myclass}[1]{\subsubsection*{Class #1} \label{#1} \addcontentsline{toc}{subsubsection}{\nameref{#1}}}
\newcommand{\myinterface}[1]{\subsubsection*{Interface #1} \label{#1} \addcontentsline{toc}{subsubsection}{\nameref{#1}}}

%\makeglossaries



%\titlehead{\centering \includegraphics{images/title}}
%\title{RaGE Pflichtenheft}
%\author{Jonas Kasper, Bernard Hohmann, Thomas Fischer, Christian Jung, Jonas Linßen}

\begin{document}
	%\maketitle
	
	%\newpage
	
	\begin{titlepage}
		%\centering \includegraphics[width=0.7\textwidth]{images/title}
		
		\titlesize \hspace*{.5cm} Random Graph Coloring Evaluation
		~\newline~\newline
		
		\themesize \hspace*{3cm} Entwurfsdokument
		\newline~\newline
		
		\authorsize Jonas Kasper, Bernard Hohmann, Thomas Fischer, Christian Jung, Jonas Linßen
	\end{titlepage}
	
	\tableofcontents
	\newpage
	
	\section{Anmerkungen zum Pflichtenheft}
	\subsection{Klarstellungen}
	\subsection{Änderungen}	
	
	\section{Übersicht}
	
	~\newpage
	\section{Model} 
	
	\mypackage{graph}
	This package contains the interfaces for the interaction with graphs. In the subpackages concrete graph-types are implemented.
	
	
	TODO graph.png UML einfügen
	
	
	\myclass{Graph}
	\textbf{Description}
	
	This class describes the abstract structure of a graph. Each graph has (independent of its concrete type) a finite amount of vertices and edges, which define a relation of vertices. The type \textbf{E} of this edges defines the concrete graph type. The class has methods for retrieving the relations given by the edges. Vertices are identified with their unique index and thus are not saved explicitly.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{Graph(edges: List<E>, numVertices: int)} \newline
			the constructor of this class \newline
			\textbf{@param edges} the edges belonging to this graph
			\textbf{@numVertices} the number of vertices this graph has
		}
		\item{
			\textbf{getNumVertices(): int} \newline
			\textbf{@return} returns the number of vertices which the graph contains
		}
		\item{
			\textbf{getVertices(): int} \newline
			convenience method for retrieving the list of vertex indices \newline
			\textbf{@return} returns the list [0 ... numVertices$-1$]
		}
		\item{
			\textbf{getEdges(): List<E>} \newline
			\textbf{@return} returns the edges giving the graph its structure
		}
		\item{
			\textbf{\textit{areIncident(vertex: int, edge: E): bool}} \newline
			\textbf{@param vertex} the index of a vertex of the graph ie. in [0 ... numVertices$-1$]\newline
			\textbf{@param edge} an edge of the graph \newline 
			\textbf{@return} returns \textbf{true} iff the vertex is incident to the given edge \newline
			\textbf{@throws GraphInconstistencyException} if \textbf{vertex} is an invalid vertex index or \textbf{edge} is not an edge of the graph
		}
		\item{
			\textbf{\textit{areAdjacent(vertex1: int, vertex2: int): bool}} \newline
			\textbf{@param vertex1} the index of a vertex of the graph ie. in [0 ... numVertices$-1$] \newline
			\textbf{@param vertex2} see \textbf{vertex1} \newline
			\textbf{@return} returns \textbf{true} iff there is an edge which is incident to both vertices \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{vertex1} or \textbf{vertex2} is not a valid vertex index
		}
		\item{
			\textbf\textit{{areAdjacent(edge1: E, edge2: E): bool}} \newline
			\textbf{@param edge1} an edge of the graph \newline
			\textbf{@param edge2} another edge of the graph \newline
			\textbf{@return} returns \textbf{true} iff there is a vertex which is incident to both edges \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{edge1} or \textbf{edge2} is not an edge of the graph
		}
		\item{
			\textbf{\textit{getAdjacentVertices(vertex: int): List<int>}} \newline
			\textbf{@param vertex} the index of a vertex of the graph ie. in [0 ... numVertices$-1$] \newline
			\textbf{@return} returns the list of all vertices which are adjacent to \textbf{vertex} \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{vertex} is not a valid vertex index
		}
		\item{
			\textbf{\textit{getAdjacentEdges(edge: E): bool}} \newline
			\textbf{@param edge} an edge of the graph \newline
			\textbf{@return} returns the list of all edges which are adjacent to \textbf{edge} \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{edge} is not an edge of the graph
		}
		\item{
			\textbf{\textit{getIncidentEdges(vertex: int): List<E>}} \newline
			\textbf{@param vertex} the index of a vertex of the graph ie. in [0 ... numVertices$-1$] \newline
			\textbf{@return} returns the list of all edges incident to \textbf{vertex} \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{vertex} is an invalid vertex index
		}
		\item{
			\textbf{\textit{getIncidentVertices(edges: List<E>): List<int>}} \newline
			\textbf{@param edges} a list of edges of the graph \newline
			\textbf{@return} returns the list of all vertices which are incident to any of the edges in the list \newline
			\textbf{@throws GraphInconsistencyException} if there is an edge in \textbf{edges}, which is not an edge of the graph
			
		}
		\item{
			\textbf{\textit{toRAGE(): List<String>}} \newline
			\textbf{@return} returns the line-by-line representation of the graph as specified in the RAGE-data format
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{Edge}
	\textbf{Description}
	
	An edge always defines an adjacency-relation of the vertices incident to it. Moreover this class provides methods to compare edges.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{\textit{getVertices(): List<int>}} \newline
			\textbf{@return} returns the list of all indices of vertices incident to this edge
		}
		\item{
			\textbf{\textit{equals(edge: E): bool}} \newline
			\textbf{@return} returns \textbf{true} iff \textbf{edge} equals the edge this method is invoked upon. Note that the notion of equality depends on the concrete implementation.
		}
		\item{
			\textbf{\textit{compareTo(edge: E): int}} \newline
			\textbf{@return} returns \textbf{-1}/\textbf{0}/\textbf{1} if \textbf{edge} is greater/equal/smaller than the edge this method is invoked upon. Note that the notions of order and equality depend on the concrete implementation.
		}
	\end{enumerate}
	
	\newpage
	
	\myclass{GraphProperties}
	
	\textbf{Description}
	
	This class is required for exchanging data between controller and model, especially to signal the settings required to generate graphs. It assures that the following graph-properties can be retrieved and set at all times:
	
	\begin{enumerate}[--]
		\item{''graphTypes'' -- a const list of strings, initialised with [''simpleUndirectedGraph'', ''simpleHyperGraph'']}
		\item{''type'' -- a string}
		\item{''numVertices'' -- a nonnegative integer}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{GraphBuilder}
	
	\textbf{Description}
	This class is a factory class to generate graphs of type \textbf{G} by given GraphProperties \textbf{G} as well as to modify graphs of this type.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{\textit{\underline{generateGraph(properties: P): G}}} \newline
			\textbf{@param properties} the properties which the generated graphs will have \newline
			\textbf{@return} returns a randomly generated graph satisfying the specified \textbf{properties}
		}
		\item{
			\textbf{\textit{\underline{deleteVertex(graph: G, vertex: int): G}}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param vertex} the index of a vertex of \textbf{graph}, which will be deleted \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which the vertex with index \textbf{vertex} and all edges incident to it are deleted \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{graph} has no vertex with index \textbf{vertex} 
		}
		\item{
			\textbf{\textit{\underline{addVertex(graph: G): G}}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@return} returns a modified copy of \textbf{graph} which has precisely one isolated vertex more
		}
		\item{
			\textbf{\textit{\underline{swapVertices(graph: G, vertex1: int, vertex2: int): G}}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param vertex1} the index of a vertex of \textbf{graph} \newline
			\textbf{@param vertex2} the index of another vertex of \textbf{graph} \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which the vertices having index \textbf{vertex1} and \textbf{vertex2} swap indices. Note this results in a different but isomorphic graph to \textbf{graph}  \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{graph} has no vertex with index \textbf{vertex1} or \textbf{vertex2} 
		}
		\item{
			\textbf{\textit{\underline{deleteEdge(graph: G, edge: E): G}}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param edge} the edge which is going to be deleted \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which \textbf{edge} is deleted, if it was an edge in \textbf{graph}. Otherwise it just returns \textbf{graph}
		}
		
		~\newpage
		
		\item{
			\textbf{\textit{\underline{addEdge(graph: G, edge: E): G}}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param edge} the edge which is going to be inserted \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which \textbf{edge} is inserted if it wasnt already an edge in \textbf{graph} otherwise it returns just \textbf{graph}. Note that the edge may contain vertices which are not in \textbf{graph}, since missing vertices will automatically be added
		}
		\item{
			\textbf{\textit{\underline{deleteIsolatedVertices(graph: G): G}}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which all isolated vertices are deleted		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{GraphInconsistencyException}
	\textbf{Description}
	
	This class extends the usual Java Exception to an exception specifically thrown when graphs are treated wrong.
		
	~\newpage
	
	\mypackage{graph.simpleUndirectedGraph}
	
	In this package \textbf{simple undirected graphs} (ie. graphs where edges always connect two distinct vertices $x$ and $y$, where there is no distinction between edges $xy$ and $yx$ and where there is at most one edge $xy$) are implemented. It offers methods to generate, modify and distinct them by some (for simple undirected graphs well defined) criterions.
		
	\myclass{SimpleUndirectedGraph}
	
	\textbf{Description}
	
	This class concretizes the abstract Graph class in the sense of simple undirected graphs. As mentioned such a graph does not contain any loops or multiedges. Besides incidence relations, this class offers methods to identify properties of simple undirected graphs.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{SimpleUndirectedGraph(edges: List<SimpleUndirectedEdge>, numVertices: int)} \newline
			a constructor for this class \newline
			\textbf{@param edges} the edges contained in this graph \newline
			\textbf{@param numVertices} the amount of vertices this graph being strictly greater than zero \newline
			\textbf{@throws GraphInconsistencyException} if numVertices $\leq 0$ or if there is an edge with a vertex $\geq$ \textbf{numVertices} or of there exists an edge more than once
		}
		\item{
			\textbf{SimpleUndirectedGraph(rageFormat: List<String>)} \newline
			another constructor for this class \newline
			\textbf{@param rageFormat} the lines of the line by line representation as specified in the RAGE data-format. \newline
			\textbf{@throws GraphInconsistencyException} if rageFormat is not a valid representation of SimpleUndirectedGraph
		}
		\item{
			\textbf{getVerticesBFS(): List<int>} \newline
			\textbf{@return} returns the list of vertices of the graph in the order of a breadth first search
		}
		\item{
			\textbf{areIncident(vertex: int, edge: SimpleUndirectedEdge): bool} \newline
			\textbf{@param vertex} the index of a vertex of the graph ie. in [0 ... numVertices$-1$]\newline
			\textbf{@param edge} an edge of the graph \newline 
			\textbf{@return} returns \textbf{true} iff the vertex is incident to the given edge \newline
			\textbf{@throws GraphInconstistencyException} if \textbf{vertex} is an invalid vertex index or \textbf{edge} is not an edge of the graph
		}
		\item{
			\textbf{areAdjacent(vertex1: int, vertex2: int): bool} \newline
			\textbf{@param vertex1} the index of a vertex of the graph ie. in [0 ... numVertices$-1$] \newline
			\textbf{@param vertex2} see \textbf{vertex1} \newline
			\textbf{@return} returns \textbf{true} iff there is an edge which is incident to both vertices \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{vertex1} or \textbf{vertex2} is not a valid vertex index
		}
		\item{
			\textbf{areAdjacent(edge1: SimpleUndirectedEdge, edge2: SimpleUndirectedEdge): bool} \newline
			\textbf{@param edge1} an edge of the graph \newline
			\textbf{@param edge2} another edge of the graph \newline
			\textbf{@return} returns \textbf{true} iff there is a vertex which is incident to both edges \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{edge1} or \textbf{edge2} is not an edge of the graph
		}
		\item{
			\textbf{getAdjacentVertices(vertex: int): List<int>} \newline
			\textbf{@param vertex} the index of a vertex of the graph ie. in [0 ... numVertices$-1$] \newline
			\textbf{@return} returns the list of all vertices which are adjacent to \textbf{vertex} \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{vertex} is not a valid vertex index
		}
		\item{
			\textbf{getAdjacentEdges(edge: SimpleUndirectedEdge): bool} \newline
			\textbf{@param edge} an edge of the graph \newline
			\textbf{@return} returns the list of all edges which are adjacent to \textbf{edge} \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{edge} is not an edge of the graph
		}
		\item{
			\textbf{getIncidentEdges(vertex: int): List<SimpleUndirectedEdge>} \newline
			\textbf{@param vertex} the index of a vertex of the graph ie. in [0 ... numVertices$-1$] \newline
			\textbf{@return} returns the list of all edges incident to \textbf{vertex} \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{vertex} is an invalid vertex index
		}
		\item{
			\textbf{getIncidentVertices(edges: List<SimpleUndirectedEdge>): List<int>} \newline
			\textbf{@param edges} a list of edges of the graph \newline
			\textbf{@return} returns the list of all vertices which are incident to any of the edges in the list \newline
			\textbf{@throws GraphInconsistencyException} if there is an edge in \textbf{edges}, which is not an edge of the graph
			
		}
		\item{
			\textbf{isConnected(): bool} \newline
			\textbf{@return} returns \textbf{true} iff the graph is connected ie. iff for any two vertices there is a sequence of edges where any two consecutive edges are adjacent
		}
		\item{
			\textbf{isForest(): bool} \newline
			\textbf{@return} returns \textbf{true} iff the graph is a forest ie. acyclic
		}
		\item{
			\textbf{isBipartite(): bool} \newline
			\textbf{@return} returns \textbf{true} iff the vertex set can be partitioned into two parts such that no two vertices from the same partition are adjacent
		}
		\item{
			\textbf{isPlanar(): bool} \newline
			\textbf{@return} returns \textbf{true} iff the graph has an embedding into the plane such that no two edges intersect
		}
		\item{
			\textbf{toRage(): List<String>} \newline
			\textbf{@return} returns the line-by-line representation of the graph as specified in the RAGE-data format
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{SimpleUndirectedEdge}
	
	\textbf{Description}
	
	This class concretizes the class Edge in the sense of a simple undirected edge. It always relates two distinct vertices.
		
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{SimpleUndirectedEdge(vertex1: int, vertex2: int)} \newline
			a constructor for this class \newline
			\textbf{@param vertex1} the index of the index of the first vertex this edge is incident to \newline
			\textbf{@param vertex2} the index of the index of the second this edge is incident to \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{vertex1} equals \textbf{vertex2}
		}
		\item{
			\textbf{getVertices(): List<int>} \newline
			\textbf{@return} returns the list of all indices of vertices incident to this edge
		}
		\item{
			\textbf{equals(edge: E): bool} \newline
			\textbf{@return} returns \textbf{true} iff both edges are adjacent to the same two vertices
		}
		\item{
			\textbf{compareTo(edge: E): int} \newline
			The notion of order between edges $(x,y)$ and $(u,v)$ with $x\leq y$ and $u\leq v$ is defined by $(x,y)<(u,v)$ iff $x<u$ or ($x=u$ and $y < v$) \newline
			\textbf{@return} returns \textbf{-1}/\textbf{0}/\textbf{1} if \textbf{edge} is greater/equal/smaller than the edge this method is invoked upon
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{SimpleUndirectedGraphProperties}
	
	\textbf{Description}
	
	This class is an extension of the GraphProperties class and serves as collection of data for exchange between controller and model, especially to signal the settings required for generating simple undirected graphs. It assures that the following properties can be retrieved and set at all times:
	
	\begin{enumerate}[--]
		\item{''minDegree'' -- a nonnegative integer}
		\item{''maxDegree'' -- a nonnegative integer}
		\item{''connected'' -- a boolean}
		\item{''forest'' -- a boolean}
		\item{''bipartite'' -- a boolean}
		\item{''planar'' -- a boolean}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{SimpleUndirectedGraphBuilder}
	
	\textbf{Description}
	
	This class concretizes the GraphBuilder class by offering methods for randomly generating simple undirected graphs after given SimpleUndirectedGraphProperties as well as modifying them.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{\underline{generate(properties: SimpleUndirectedGraphProperties): SimpleUndirectedGraph}} \newline
			\textbf{@param properties} the properties which the generated graphs will have \newline
			\textbf{@return} returns a randomly generated graph satisfying the specified \textbf{properties}
		}
		\item{
			\textbf{\underline{deleteVertex(graph: SimpleUndirectedGraph, vertex: int): SimpleUndirectedGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param vertex} the index of a vertex of \textbf{graph}, which will be deleted \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which the vertex with index \textbf{vertex} and all edges incident to it are deleted \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{graph} has no vertex with index \textbf{vertex} 
		}
		\item{
			\textbf{\underline{addVertex(graph: SimpleUndirectedGraph): SimpleUndirectedGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@return} returns a modified copy of \textbf{graph} which has precisely one isolated vertex more
		}
		\item{
			\textbf{\underline{copyVertex(graph: SimpleUndirectedGraph, vertex: int): SimpleUndirectedGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param vertex} the index of a vertex of \textbf{graph}, which will be copied \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which the vertex with index \textbf{vertex} is duplicated i.e. there is a new vertex which has precisely the same neighborhood \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{graph} has no vertex with index \textbf{vertex} 
		}
		\item{
			\textbf{\underline{swapVertices(graph: SimpleUndirectedGraph, vertex1: int, vertex2: int): SimpleUndirectedGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param vertex1} the index of a vertex of \textbf{graph} \newline
			\textbf{@param vertex2} the index of another vertex of \textbf{graph} \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which the vertices having index \textbf{vertex1} and \textbf{vertex2} swap indices. Note this results in a different but isomorphic graph to \textbf{graph}  \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{graph} has no vertex with index \textbf{vertex1} or \textbf{vertex2} 
		}
		\item{
			\textbf{\underline{contractVertices(graph: SimpleUndirectedGraph, vertex1: int, vertex2: int): SimpleUndirectedGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param vertex1} the index of a vertex of \textbf{graph} \newline
			\textbf{@param vertex2} the index of another vertex of \textbf{graph} \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which the vertices having index \textbf{vertex1} and \textbf{vertex2} are contracted to a single vertex. Resulting loops will be deleted and multiedges will be reduced to one edge \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{graph} has no vertex with index \textbf{vertex1} or \textbf{vertex2} 
		}
		\item{
			\textbf{\underline{deleteEdge(graph: SimpleUndirectedGraph, edge: SimpleUndirectedEdge): SimpleUndirectedGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param edge} the edge which is going to be deleted \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which \textbf{edge} is deleted, if it was an edge in \textbf{graph}. Otherwise it just returns \textbf{graph}
		}
		
		\item{
			\textbf{\underline{addEdge(graph: SimpleUndirectedGraph, edge: SimpleUndirectedEdge): SimpleUndirectedGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param edge} the edge which is going to be inserted \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which \textbf{edge} is inserted if it wasnt already an edge in \textbf{graph} otherwise it returns just \textbf{graph}. Note that the edge being added may contain vertices which are not in \textbf{graph}, since missing vertices will automatically be added
		}
		\item{
			\textbf{\underline{deleteIsolatedVertices(graph: SimpleUndirectedGraph): SimpleUndirectedGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which all isolated vertices are deleted		}
	\end{enumerate}
	
	~\newpage
	
	\mypackage{graph.simpleHyperGraph}
	
	In this package simple hypergraphs (i.e. graphs whose edges are sets of at least two distinct vertices and whose edges dont overlap in more than one vertex) are implemented. It offers the functionality to generate, modify and distinct them by some for simple hypergraph welldefined criterions.
	
	\myclass{SimpleHyperGraph}
	
	\textbf{Description}
	
	This class concretizes the graph class in the sense of a simple hypergraphs. Besides incidence relations this class offers methods to identify some of their properties.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{SimpleHyperGraph(edges: List<SimpleHyperEdge>, numVertices: int)} \newline
			A constructor for this class \newline
			\textbf{@param edges} the edges this graph contains \newline
			\textbf{@param numVertices} the amount of vertices this graph has \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{numVertices} $\leq 0$, if there is a hyperedge with a vertex $\geq$ \textbf{numVertices} or if the resulting hypergraph is not simple
		}
		\item{
			\textbf{SimpleHyperGraph(rageFormat: List<String>)} \newline
			A constructor of this class, assuring that this graph type can be loaded from harddrive \newline
			\textbf{@param rageFormat} the line by line representation of the graph as specified in the RAGE data format
		}
		\item{
			\textbf{getVerticesBFS(): List<int>} \newline
			\textbf{@return} returns the list of vertices of the graph in the order of a breadth first search
		}
		\item{
			\textbf{areIncident(vertex: int, edge: SimpleHyperEdge): bool} \newline
			\textbf{@param vertex} the index of a vertex of the graph ie. in [0 ... numVertices$-1$]\newline
			\textbf{@param edge} an edge of the graph \newline 
			\textbf{@return} returns \textbf{true} iff the vertex is incident to the given edge \newline
			\textbf{@throws GraphInconstistencyException} if \textbf{vertex} is an invalid vertex index or \textbf{edge} is not an edge of the graph
		}
		\item{
			\textbf{areAdjacent(vertex1: int, vertex2: int): bool} \newline
			\textbf{@param vertex1} the index of a vertex of the graph ie. in [0 ... numVertices$-1$] \newline
			\textbf{@param vertex2} see \textbf{vertex1} \newline
			\textbf{@return} returns \textbf{true} iff there is an edge which is incident to both vertices \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{vertex1} or \textbf{vertex2} is not a valid vertex index
		}
		\item{
			\textbf{areAdjacent(edge1: SimpleHyperEdge, edge2: SimpleHyperEdge): bool} \newline
			\textbf{@param edge1} an edge of the graph \newline
			\textbf{@param edge2} another edge of the graph \newline
			\textbf{@return} returns \textbf{true} iff there is a vertex which is incident to both edges \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{edge1} or \textbf{edge2} is not an edge of the graph
		}
		\item{
			\textbf{getAdjacentVertices(vertex: int): List<int>} \newline
			\textbf{@param vertex} the index of a vertex of the graph ie. in [0 ... numVertices$-1$] \newline
			\textbf{@return} returns the list of all vertices which are adjacent to \textbf{vertex} \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{vertex} is not a valid vertex index
		}
		\item{
			\textbf{getAdjacentEdges(edge: SimpleHyperEdge): bool} \newline
			\textbf{@param edge} an edge of the graph \newline
			\textbf{@return} returns the list of all edges which are adjacent to \textbf{edge} \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{edge} is not an edge of the graph
		}
		\item{
			\textbf{getIncidentEdges(vertex: int): List<SimpleHyperEdge>} \newline
			\textbf{@param vertex} the index of a vertex of the graph ie. in [0 ... numVertices$-1$] \newline
			\textbf{@return} returns the list of all edges incident to \textbf{vertex} \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{vertex} is an invalid vertex index
		}
		\item{
			\textbf{getIncidentVertices(edges: List<SimpleHyperEdge>): List<int>} \newline
			\textbf{@param edges} a list of edges of the graph \newline
			\textbf{@return} returns the list of all vertices which are incident to any of the edges in the list \newline
			\textbf{@throws GraphInconsistencyException} if there is an edge in \textbf{edges}, which is not an edge of the graph
			
		}
		\item{
			\textbf{isConnected(): bool} \newline
			\textbf{@return} returns \textbf{true} iff the graph is connected ie. iff for any two vertices there is a sequence of edges where any two consecutive edges are adjacent
		}
		\item{
			\textbf{toRage(): List<String>} \newline
			\textbf{@return} returns the line-by-line representation of the graph as specified in the RAGE-data format
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{SimpleHyperEdge}
	
	\textbf{Description}
	
	This class concretizes the class edge in the sense of a hyperedge. It always relates at least two distinct vertices.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{SimpleHyperEdge(vertices: List<int>)} \newline
			A constructor for this class \newline
			\textbf{@param vertices} the vertices this edge sets in relation \newline
			\textbf{@throws GraphInconsistencyException} if the list is empty, contains just one vertex or any vertex twice			
		}
		\item{
			\textbf{getVertices(): List<int>} \newline
			\textbf{@return} returns the list of all indices of vertices incident to this edge
		}
		\item{
			\textbf{equals(edge: E): bool} \newline
			\textbf{@return} returns \textbf{true} both edges are adjacent to the same vertices
		}
		\item{
			\textbf{compareTo(edge: E): int} \newline
			The notion of order between edges $(x_1, ..., x_n)$ and $(y_1, ..., y_m)$ with $x_1 < ... < x_n$, $y_1 < ... < y_m$ and $n \leq m$ is defined by $(x1, ..., x_n)<(y_1,...,y_n)$ iff $x_1 < y_1$ or ($x_1=y_1$ and $x_2 < y_2$) or ... or ($x_1 = y_1$ and ... and $x_n = y_n$ and $n < m$) \newline
			\textbf{@return} returns \textbf{-1}/\textbf{0}/\textbf{1} if \textbf{edge} is greater/equal/smaller than the edge this method is invoked upon
		}
	\end{enumerate}
	
	~\newpage
	
	\myclass{SimpleHyperGraphProperties}
	
	\textbf{Description}
	
	This class is an extension of the GraphProperties class and is likely meant for the exchange of data between controller and model, especially for transferring the settings required for generating simple hyper graphs. It assures that the following graph properties can be retrieved and set at all times:
	
	\begin{enumerate}[--]
		\item{''uniform'' -- a nonnegative integer}
		\item{''minDegree'' -- a nonnegative integer}
		\item{''maxDegree'' -- a nonnegative integer}
		\item{''connected'' -- a boolean}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{SimpleHyperGraphBuilder}
	
	\textbf{Description}
	
	This class concretizes the GraphBuilder class by offering methods for randomly generating simple hypergraphs after given SimpleHyperGraphProperties as well as modifying them.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{\underline{generate(properties: SimpleHyperGraphProperties): SimpleHyperGraph}} \newline
			\textbf{@param properties} the properties which the generated graphs will have \newline
			\textbf{@return} returns a randomly generated graph satisfying the specified \textbf{properties}
		}
		\item{
			\textbf{\underline{deleteVertex(graph: SimpleHyperGraph, vertex: int): SimpleHyperGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param vertex} the index of a vertex of \textbf{graph}, which will be deleted \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which the vertex with index \textbf{vertex} and all edges incident to it are deleted \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{graph} has no vertex with index \textbf{vertex} 
		}
		\item{
			\textbf{\underline{addVertex(graph: SimpleHyperGraph): SimpleHyperGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@return} returns a modified copy of \textbf{graph} which has precisely one isolated vertex more
		}
		\item{
			\textbf{\underline{swapVertices(graph: SimpleHyperGraph, vertex1: int, vertex2: int): SimpleHyperGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param vertex1} the index of a vertex of \textbf{graph} \newline
			\textbf{@param vertex2} the index of another vertex of \textbf{graph} \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which the vertices having index \textbf{vertex1} and \textbf{vertex2} swap indices. Note this results in a different but isomorphic graph to \textbf{graph}  \newline
			\textbf{@throws GraphInconsistencyException} if \textbf{graph} has no vertex with index \textbf{vertex1} or \textbf{vertex2} 
		}
		\item{
			\textbf{\underline{deleteEdge(graph: SimpleHyperGraph, edge: SimpleHyperEdge): SimpleHyperGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param edge} the edge which is going to be deleted \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which \textbf{edge} is deleted, if it was an edge in \textbf{graph}. Otherwise it just returns \textbf{graph}
		}
		
		\item{
			\textbf{\underline{addEdge(graph: SimpleHyperGraph, edge: SimpleHyperEdge): SimpleHyperGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@param edge} the edge which is going to be inserted \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which \textbf{edge} is inserted if it wasnt already an edge in \textbf{graph} otherwise it returns just \textbf{graph}. Note that the edge being added may contain vertices which are not in \textbf{graph}, since missing vertices will automatically be added
		}
		\item{
			\textbf{\underline{deleteIsolatedVertices(graph: SimpleHyperGraph): SimpleHyperGraph}} \newline
			\textbf{@param graph} the graph which is going to be modified \newline
			\textbf{@return} returns a modified copy of \textbf{graph} in which all isolated vertices are deleted		}
	\end{enumerate}
	
	~\newpage
	
	
	
	
	\mypackage{heuristic}
	The package contains the interface for implementing heuristics. In the subpackages some heuristics for the total coloring conjecture as well as for the Erdös-Faber-Lovasz conjecture are implemented.
	
	TODO heuristic.png UML
	
	\myclass{Heuristic}
	
	\textbf{Description}
	
	The class is the abstract interface of a heuristic which is applied to a graph of typ \textbf{G} which has a result of type \textbf{R}.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{Heuristic(properties: HeuristicProperties)} \newline
			A constructor for this class \newline
			\textbf{@param properties} the properties defining this heuristic
		}
		\item{
			\textbf{getProperties(): HeuristicProperties} \newline
			\textbf{@return} returns the properties of this heuristic
		}
		\item{
			\textbf{\textit{applyTo(graph: G): R}} \newline
			\textbf{@param graph} the graph of type \textbf{G} on which the heuristic will be applied \newline
			\textbf{@return} returns the result of the heuristic application
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{HeuristicResult}
	
	\textbf{Description}
	
	This class is the abstract interface of the result of a specific calculation of an heuristic \textbf{H} on a specific graph of type \textbf{G}. 
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{HeuristicResult(graph: G, heuristic: H)} \newline
			The constructor of this class \newline
			\textbf{@param graph} the graph this heuristic was calculated upon \newline
			\textbf{@param heuristic} the heuristic by which the result was calculated
		}
		\item{
			\textbf{getGraph(): G} \newline
			\textbf{@return} returns the graph this result was calculated upon
		}
		\item{
			\textbf{getHeuristic(): H} \newline
			\textbf{@return} returns the heuristic by which this result was calculated
		}
		\item{
			\textbf{\textit{toRAGE(): List<String>}} \newline
			\textbf{@return} returns the line-by-line representation of this heuristic result as specified in the RAGE data format
		}
	\end{enumerate}
	
	~\newpage
	
	\myclass{HeuristicProperties}
	
	\textbf{Description}
	
	This class serves as collection of data for exchange between controller and model, especially to transfer properties of heuristics. It assures that the following properties may be retrieved and set at any time:
	
	\begin{enumerate}[--]
		\item{''name'' -- ein String}
		\item{"valid" -- ein Boolean}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{DataPool}
	\textbf{Description}
	
	The class manages the application of heuristics of type \textbf{H} on graphs of type \textbf{G} which results have type \textbf{R}. It assures that every heuristic stored in the pool is applied to every graph stored in the pool. Moreover it gathers statistics over this applications.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{DataPool(rageFormat: List<String>)} \newline
			A constructor for this class, assuring that the datapool can be loaded from harddrive \newline
			\textbf{@param rageFormat} the line by line representation of a datapool as specified in the RAGE data format.
		}
		\item{
			\textbf{getHeuristics(): List<H>} \newline
			\textbf{@return} returns the list of heuristics currently in this data pool
		}
		\item{
			\textbf{addHeuristic(heuristic: H)} \newline
			\textbf{@param heuristic} the heuristic to be added to data pool, which then will be applied to every graph in the data pool \newline
			\textbf{@throws DataInconsistencyException} if heuristic may not be applied on graphs of type \textbf{G} or does not has results of type \textbf{R}
		}
		\item{
			\textbf{getGraphs(): List<G>} \newline
			\textbf{@return} returns the list of graphs currently in this data pool
		}
		\item{
			\textbf{addGraph(graph: G)} \newline
			\textbf{@param graph} the graph to be added to the data pool, on which then all heuristics in the data pool will be applied \newline
			\textbf{@throws DataInconsistencyException} if heuristics of type \textbf{H} may not be applied on this graph
		}
		\item{
			\textbf{getResults(): List<R>} \newline
			\textbf{@return} returns the list of all results calculated on graphs by heuristics in this data pool
		}
		\item{
			\textbf{getResults(heuristic: H): List<R>} \newline
			\textbf{@param heuristic} the heuristic the results were calculated by \newline
			\textbf{@return} returns all results calculated by \textbf{heuristic} on graphs in this data pool 
		}
		\item{
			\textbf{getResults(graph: G)} \newline
			\textbf{@param graph} the graph the results were calculated upon \newline
			\textbf{@return} returns all results calculated on \textbf{graph} by heuristics in this data pool
		}
		~\newpage
		\item{
			\textbf{getStatistics(heuristic: H): HeuristicStatistic} \newline
			\textbf{@param heuristic} the heuristic whose statistics are requested \newline
			\textbf{@return} returns the statistic gathered for \textbf{heuristic} \newline
			\textbf{@throws DataInconsistencyException} if \textbf{heuristic} is not a heuristic of this data pool
		}
		\item{
			\textbf{toRAGE(): List<String>} \newline
			\textbf{@return} returns the line by line representation of this data pool as specified in the RAGE data format
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{HeuristicStatistic}
	
	This class collects some statistics overt the applications of a specific heuristic within a data pool. It assures that the following properties may be retrieved at any time:
	
	\begin{enumerate}[--]
		\item{''minRuntime'' -- a floating point number}
		\item{''avgRuntime'' -- a floating point number}
		\item{"maxRuntime" -- a floating point number}
		\item{"numApplications" -- a nonnegative integer}
		\item{"numSuccesses" -- a nonnegative integer}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{DataInconsistencyException}
	
	\textbf{Description}
	
	This class extends the usual Java Exception to an exception specifically thrown when data pools are treated wrong.
	
	~\newpage
	
	
	
	
	
	\mypackage{heuristic.totalColoring}
	In this package and its subpackages some heuristics for the \textbf{total coloring conjecture} (ie. any simple undirected graph with maximal degree $\Delta$ has a total coloring with $\Delta + 2$ colors) are implemented.
	
	TODO tc.png UML
	
	\myclass{TCHeuristic}
	
	\textbf{Description}
	
	This abstract class is the abstract interface for a total coloring heuristic. It assures that any total coloring heuristic is calculated on SimpleUndirectedGraphs and returns a TCResult as result. It provides some methods, which any total coloring heuristic needs, such as coloring vertices and edges.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item[\#]{
			\textbf{colorVertex(vertex: int, color: int, data: TCData, result: TCResult)} \newline
			\textbf{@param vertex} the vertex to be colored \newline
			\textbf{@param color} the color which will be assigned to the vertex \newline
			\textbf{@param data} the data required for the calculation of a total coloring \newline
			\textbf{@param result} the resulting total coloring
		}
		\item[\#]{
			\textbf{colorEdge(edge: SimpleUndirectedEdge, color: int, data: TCData, result: TCResult)} \newline
			\textbf{@param edge} the edge to be colored \newline
			\textbf{@param color} the color which will be assigned to the edge \newline
			\textbf{@param data} the data required for the calculation of a total coloring \newline
			\textbf{@param result} the resulting total coloring
		}
		\item{
			\textbf{equals(heuristic: TCHeuristic): bool} \newline
			\textbf{@param heuristic} another TCHeuristic this will be compared to \newline
			\textbf{@return} returns \textbf{true} iff the other TCHeuristic of of the same type and has exactly the same properties
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCResult}
	
	\textbf{Description}
	
	This class represents a total coloring of a simple undirected graph ie. a coloring of vertices and edges, such that no two adjacent or incident objects share the same color. Colors are represented as integers.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{TCResult(graph: SimpleUndirectedGraph, heuristic: TCHeuristic)} \newline
			A constructor for this class
			\textbf{@param graph} the graph this result was calculated upon \newline
			\textbf{@param heuristic} the heuristic this result was calculated by
		}
		\item{
			\textbf{getVertexColor(vertex: int): int} \newline
			\textbf{@param vertex} the vertex whose color is requested \newline
			\textbf{@return} returns the color of \textbf{vertex} \newline
			\textbf{@throws DataInconsistencyException} if vertex has no color
		}
		\item{
			\textbf{setVertexColor(vertex: int, color: int)} \newline
			\textbf{@param vertex} the vertex to be colored \newline
			\textbf{@param color} the color to color \textbf{vertex} with
		}
		\item{
			\textbf{getEdgeColor(edge: SimpleUndirectedEdge): int} \newline
			\textbf{@param edge} the edge whose color is requested \newline
			\textbf{@return} returns the color of \textbf{edge} \newline
			\textbf{@throws DataInconsistencyException} if edge has no color
		}
		\item{
			\textbf{setEdgeColor(edge: SimpleUndirectedEdge, color: int)} \newline
			\textbf{@param edge} the edge to be colored \newline
			\textbf{@param color} the color to color \textbf{edge} with
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCData}
	
	\textbf{Description}
	
	This abstract class encapsulates the data required temporarly to calculate a total coloring, such as the lists of \textbf{free colors} of uncolored vertices and edges (ie. the colors which are not used by other objects adjacent / incident to them). Moreover it stores the weighted (vertex vs. edges) sum of how often colors are used.
	
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{TCData(graph: SimpleUndirectedGraph)} \newline
			A constructor of this class \newline
			\textbf{@param graph} the graph the heuristic is running at
		}
		\item{
			\textbf{\textit{init()}} \newline
			May be implemented to (re-)initialize the data at any time within the running heuristic
		}
		\item{
			\textbf{\textit{justColoredVertex(vertex: int)}} \newline
			May be implemented to update data anytime when a vertex was colored \newline
			\textbf{@param vertex} the vertex which was just colored
		}
		\item{
			\textbf{\textit{justColoredEdge(edge: SimpleUndirectedEdge)}} \newline
			May be implemented to update data anytime when an edge was colored \newline
			\textbf{@param edge} the edge which was just colored
		}
		\item{
			\textbf{removeFreeColor(vertex: int, color: int)} \newline
			\textbf{@param vertex} the vertex which will have one free color less \newline
			\textbf{@param color} the color which \textbf{vertex} mustnt use
		}
		\item{
			\textbf{removeFreeColor(edge: SimpleUndirectedEdge, color: int)} \newline
			\textbf{@param edge} the edge which will have one free color less \newline
			\textbf{@param color} the color which \textbf{edge} mustnt use
		}
		\item{
			\textbf{getFlex(vertices: List<int>): int} \newline
			\textbf{@param vertices} the set of vertices whose flexibility should be calculated \newline
			\textbf{@return} returns the flexibility of these vertices ie. \# of colors free for all vertices -- \# of \textbf{vertices}
		}
		\item{
			\textbf{getFlex(edges: List<SimpleUndirectedEdge>): int} \newline
			\textbf{@param vertices} the set of vertices whose flexibility should be calculated \newline
			\textbf{@return} returns the flexibility of these vertices ie. \# of colors which are free for all edges -- \# of \textbf{edges}
		}
		\item{
			\textbf{getFlex(vertices: List<int>, edges: List<SimpleUndirectedEdge>): int} \newline
			\textbf{@param vertices} a set of vertices \newline
			\textbf{@param edges} a set of edges \newline
			\textbf{@return} returns the flexibility of these objects ie. \# of colors which are free for all objects -- \# of \textbf{objects}
		}
		\item{
			\textbf{getColorWeight(color: int): int} \newline
			\textbf{@param color} the color whose weight is requested \newline
			\textbf{@return} returns the weight of this color ie. how often it was used weighted differently by vertices and edges
		}
		\item{
			\textbf{setColorWeight(color: int, weight: int)} \newline
			\textbf{@param color} the color whose weight will be updated \newline
			\textbf{@param weight} the new weight of \textbf{color}
		}
		\item{
			\textbf{getFreeVertexColors(vertex: int): List<int>} \newline
			\textbf{@param vertex} the vertex whose free colors are requested \newline
			\textbf{@return} returns the list of free colors of \textbf{vertex}
		}
		\item{
			\textbf{getFreeVertexColors(edge: SimpleUndirectedEdge): List<int>} \newline
			\textbf{@param edge} the edge whose free colors are requested \newline
			\textbf{@return} returns the list of free colors of \textbf{edge}
		}
	\end{enumerate}
	
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCFlexSet}
	
	\textbf{Description}
	
	This class represents a subset of vertices and edges of a graph with a given \textbf{flexibility value} (ie. \# colors free for all objects -- \# objects) used heavily in some TCHeuristics.
	
	\textbf{Documentation}
	\begin{enumerate}[\#]
		\item{
			\textbf{TCFlexSet(vertices: List<int>, value: int)} \newline
			A constructor of this class \newline
			\textbf{@param vertices} some vertices \newline
			\textbf{@param value} the flexibility value of \textbf{vertices}
		}
		\item{
			\textbf{TCFlexSet(edges: List<SimpleUndirectedEdge>, value: int)} \newline
			A constructor of this class \newline
			\textbf{@param edges} some edges \newline
			\textbf{@param value} the flexibility value of \textbf{edges}
		}
		\item{
			\textbf{TCFlexSet(vertices: List<int>, edges: List<SimpleUndirectedEdge>, value: int)} \newline
			A constructor of this class \newline
			\textbf{@param vertices} some vertices \newline
			\textbf{@param edges} some edges \newline
			\textbf{@param value} the flexibility value of the set of objects in \textbf{vertices} and \textbf{edges}
		}
		\item{
			\textbf{getVertices(): List<int>} \newline
			\textbf{@return} returns the vertices in this flex set
		}
		\item{
			\textbf{getEdges(): List<SimpleUndirectedEdge>} \newline
			\textbf{@return} returns the edges in this flex set
		}
		\item{
			\textbf{getValue(): int} \newline
			\textbf{@return} returns the flexibility value of this set of objects
		}
	\end{enumerate}
	
	~\newpage
	
	
	
	
	\mypackage{heuristic.totalColoring.greedy}
	In this package some greedy heuristics for the total coloring conjecture are implemented. They all have in common, that the vertices are colored first and the edges are colored afterwards. The heuristics differ in the way the edges are colored.
	
	TODO tcgreedy.png UML
	
	\myclass{TCGreedyData}
	
	\textbf{Description}
	
	Since TCData is abstract this class is required such that the TCGreedy heuristic has its own data class, even if with respect to TCData no additional attributes or methods are added.
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCGreedy}
	
	\textbf{Description}
	
	This class implements the TCGreedy heuristic which tries to calculate a total coloring as specified in the addendum.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleUndirectedGraph): TCResult} \newline
			\textbf{@param graph} the graph this heuristic will be applied on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCGreedyOneData}
	
	\textbf{Description}
	
	This class stores all uncolored edges with exactly one free color temporarily.
	
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{init()} \newline
			initializes the list of all uncolored edges with exactly one free color
		}
		\item{
			\textbf{justColoredEdge(edge: SimpleUndirectedEdge)} \newline
			updates the list of edges with exactly one free color \newline
			\textbf{@param edge} the edge which was just colored
		}
		\item[-]{
			\textbf{calcSingularEdges()} \newline
			updates the list of edges with exactly one free color
		}
		\item{
			\textbf{getMinimalSingularEdge(): SimpleUndirectedEdge} \newline
			\textbf{@return} returns the minimal edge with exactly one free color with respect to the order defined on edges
		}
	\end{enumerate}
	
	
	
	\myclass{TCGreedyOne}
	
	\textbf{Description}
	
	This class implements the TCGreedyOne heuristic which tries to calculate a total coloring as specified in the addendum.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleUndirectedGraph): TCResult} \newline
			\textbf{@param graph} the graph this heuristic will be calculated on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCGreedyFewData}
	
	\textbf{Description}
	
	This class stores all uncolored edges sorted first by their amount of free colors and then by the order defined on edges.
	
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{init()} \newline
			initializes the list of uncolored edges
		}
		\item{
			\textbf{justColoredEdge(edge: SimpleUndirectedEdge)} \newline
			updates the list of uncolored edges
		}
		\item{
			\textbf{getMinimalUncoloredEdge(): SimpleUndirectedEdge} \newline
			\textbf{@return} returns the minimal uncolored edge with respect to the number of free colors and the order defined on edges
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCGreedyFew}
	
	\textbf{Description}
	
	This class implements the TCGreedyFew heuristic, which tries to calculate a total coloring as specified in the addendum.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleUndirectedGraph): TCResult} \newline
			\textbf{@param graph} the graph this heuristic will be calculated on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	~\newpage
	
	\myclass{TCGreedySetData}
	
	\textbf{Description}
	
	This class stores for any vertex v the subset of all uncolored edges incident to v which has the lowest flexibility value (ie. \# of colors which are free for every edge in this set -- \# of edges in the set) and is the lowest with respect to lexicographic ordering using the order defined on edges. These sets are from now on referred to as minimal flex sets
		
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{init()} \newline
			initializes the minimal flex sets
		}
		\item{
			\textbf{justColoredEdge(edge: SimpleUndirectedEdge)} \newline
			updates the minimal flex sets of the vertices incident to edge
		}
		\item[-]{
			\textbf{calcMinimalFlexSet(vertex: int)} \newline
			calculates the minimal flex set of \textbf{vertex} \newline
			\textbf{@param vertex} the vertex whose minimal flex set is calculated
		}
		\item{
			\textbf{getMinimalFlexSet(): TCFlexSet} \newline
			\textbf{@return} returns the minimal flex set belonging to the vertex with minimal index
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCGreedySet}
	
	\textbf{Description}
	
	This class implements the TCGreedySet heuristic, which tries to calculate a total coloring as specified in the addendum.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleUndirectedGraph): TCResult} \newline
			\textbf{@param graph} the graph this heuristic will be calculated on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	~\newpage
	
	\myclass{TCGreedyConData}
	
	\textbf{Description}
	
	This class stores the list of uncolored edges temporarily to compute connected subsets of uncolored edges up to a specific size.
		
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{init()} \newline
			initializes the list of uncolored edges
		}
		\item{
			\textbf{justColoredEdge(edge: SimpleUndirectedEdge)} \newline
			updates the list of uncolored edges
		}
		\item{
			\textbf{getMinimalFlexSet(): TCFlexSet} \newline
			\textbf{@return} returns the connected set of uncolored edges with minimal flexibility value (\# of colors which are free for all edges -- \# of edges) and minimal lexicographic order using the order defined on edges.
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCGreedyCon}
	
	This class implements the TCGreedyCon heuristic, which tries to calculate a total coloring as specified in the addendum.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleUndirectedGraph): TCResult} \newline
			\textbf{@param graph} the graph this heuristic will be calculated on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	
	
	~\newpage
	
	\mypackage{heuristic.totalColoring.mixedGreedy}
	In this package some heuristics for the total coloring conjecture are implemented. In comparison to the greedy heuristics, these heuristics do not seperate the coloring of vertices and edges strictly but rather alternate between them. Nethertheless they work in a similiarly greedy fashion.
	
	TODO tcmixedgreedy.png UML
	
	
	\myclass{TCMixedGreedyData}
	
	\textbf{Description}
	
	Since TCData is abstract this class is required such that the TCGreedy heuristic has its own data class, even if with respect to TCData no additional attributes or methods are added.
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCMixedGreedy}
	
	\textbf{Description}
	
	This class implements the TCMixedGreedy heuristic which tries to calculate a total coloring as specified in the addendum.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleUndirectedGraph): TCResult} \newline
			\textbf{@param graph} the graph this heuristic will be applied on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}

	
	~\newpage
	
	\myclass{TCMixedGreedyOneData}
	
	\textbf{Description}
	
	This class stores all uncolored vertices and all uncolored edges with exactly one free color temporarily.
	
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{init()} \newline
			initializes the list of all uncolored edges with exactly one free color
		}
		\item{
			\textbf{justColoredVertex(vertex: int)} \newline
			updates the lists of objects with exactly one free color \newline
			\textbf{@param vertex} the vertex which was just colored
		}
		\item{
			\textbf{justColoredEdge(edge: SimpleUndirectedEdge)} \newline
			updates the lists of objects with exactly one free color \newline
			\textbf{@param edge} the edge which was just colored
		}
		\item[-]{
			\textbf{calcSingularObjects()} \newline
			updates the lists of objects with exactly one free color
		}
		\item{
			\textbf{getMinimalSingularVertex(): int} \newline
			\textbf{@return} returns the vertex with minimal index and exactly one free color		
		}
		\item{
			\textbf{getMinimalSingularEdge(): SimpleUndirectedEdge} \newline
			\textbf{@return} returns the minimal edge with exactly one free color with respect to the order defined on edges
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCMixedGreedyOne}
	
	\textbf{Description}
	
	This class implements the TCMixedGreedyOne heuristic which tries to calculate a total coloring as specified in the addendum.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleUndirectedGraph): TCResult} \newline
			\textbf{@param graph} the graph this heuristic will be applied on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	~\newpage
	
	\myclass{TCMixedGreedyFewData}
	
	\textbf{Description}
	
	This class stores all uncolored vertices and all uncolored edges, both sorted by their number of free colors and inherent order.
	
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{init()} \newline
			initializes the list of all uncolored objects
		}
		\item{
			\textbf{justColoredVertex(vertex: int)} \newline
			updates the lists of uncolored objects \newline
			\textbf{@param vertex} the vertex which was just colored
		}
		\item{
			\textbf{justColoredEdge(edge: SimpleUndirectedEdge)} \newline
			updates the lists of uncolored objects \newline
			\textbf{@param edge} the edge which was just colored
		}
		\item{
			\textbf{getMinimalUncoloredVertex(): int} \newline
			\textbf{@return} returns the vertex with minimal amount of free colors and minimal index		
		}
		\item{
			\textbf{getMinimalUncoloredEdge(): SimpleUndirectedEdge} \newline
			\textbf{@return} returns the edge with the minimal amount of free colors and minimal order
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCMixedGreedyFew}
	
	\textbf{Description}
	
	This class implements the TCMixedGreedyFew heuristic which tries to calculate a total coloring as specified in the addendum.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleUndirectedGraph): TCResult} \newline
			\textbf{@param graph} the graph this heuristic will be applied on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	~\newpage
	
	\myclass{TCMixedGreedySetData}
	
	\textbf{Description}
	
	This class stores for every vertex the subset of edges incident to this vertex which has minimal flexibility and minimal lexicographic order using the order defined on the edges. If the vertex is uncolored, versions with the vertex added to the set and without it are considered. These sets will from now on be reffered to as flexibility sets.
	
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{init()} \newline
			initializes the list of flexibility sets
		}
		\item{
			\textbf{justColoredVertex(vertex: int)} \newline
			updates the minimal flexibility set of \textbf{vertex} \newline
			\textbf{@param vertex} the vertex which was just colored
		}
		\item{
			\textbf{justColoredEdge(edge: SimpleUndirectedEdge)} \newline
			updates the minimal flexibility sets of both vertices incident to \textbf{edge} \newline
			\textbf{@param edge} the edge which was just colored
		}
		\item[-]{
			\textbf{calcMinimalFlexSet(vertex: int)} \newline
			\textbf{@param vertex} the vertex whose minimal flexibility set will be updated
		}
		\item{
			\textbf{getMinimalFlexSet(): int} \newline
			\textbf{@return} returns the vertex with minimal amount of free colors and minimal index		
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCMixedGreedySet}
	
	\textbf{Description}
	
	This class implements the TCMixedGreedySet heuristic which tries to calculate a total coloring as specified in the addendum.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleUndirectedGraph): TCResult} \newline
			\textbf{@param graph} the graph this heuristic will be applied on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	~\newpage
	
	\myclass{TCMixedGreedyConData}
	
	\textbf{Description}
	
	This class stores uncolored vertices and edges to compute connected subsets of uncolored vertices and edges up to a specific size.
	
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{init()} \newline
			initializes the list of flexibility sets
		}
		\item{
			\textbf{justColoredVertex(vertex: int)} \newline
			updates the list of uncolored vertices \newline
			\textbf{@param vertex} the vertex which was just colored
		}
		\item{
			\textbf{justColoredEdge(edge: SimpleUndirectedEdge)} \newline
			updates the list of uncolored edges \newline
			\textbf{@param edge} the edge which was just colored
		}
		\item{
			\textbf{getMinimalFlexSet(): int} \newline
			\textbf{@return} returns the connected set of uncolored vertices and edges with minimal flexibility value (\# of colors which are free for all objects -- \# of objects) and minimal lexicographic order using the indices of vertices and the order defined on edges	
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{TCMixedGreedyCon}
	
	\textbf{Description}
	
	This class implements the TCMixedGreedyCon heuristic which tries to calculate a total coloring as specified in the addendum.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleUndirectedGraph): TCResult} \newline
			\textbf{@param graph} the graph this heuristic will be applied on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	
	
	
	~\newpage
	
	\mypackage{heuristic.erdosFaberLovasz}
	
	In this package and its subpackages some heuristics for the Erdös-Faber-Lovasz conjecture (ie. any simple hypergraph on $n$ vertices has a proper edge coloring with $n$ colors) are implemented.
	
	TODO efl.png UML
	
	\myclass{EFLHeuristic}
	
	\textbf{Description}
	
	This abstract class is the abstrac interface for an Erdös-Faber-Lovasz heuristic. It assures that every EFL-heuristic is calculated on SimpleHyperGraphs and returns an EFLResult as result. It provides some methods which any EFL-heuristic needs, such as coloring edges.
	
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{colorEdge(edge: SimpleHyperEdge, color: int, data: EFLData, result: EFLResult)} \newline
			\textbf{@param edge} the hyperedge to be colored \newline
			\textbf{@param color} the color which will be assigned to the edge \newline
			\textbf{@param data} the data required for the calculation of a proper coloring \newline
			\textbf{@param result} the resulting edge coloring
		}
		\item[+]{
			\textbf{equals(heuristic: EFLHeuristic): bool} \newline
			\textbf{@param heuristic} another EFLHeuristic this will be compared to \newline
			\textbf{@return} returns \textbf{true} iff the other EFLHeuristic is of the same type and has exactly the same properties
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{EFLResult}
	
	\textbf{Description}
	
	This class represents an edge coloring of a simple hypergraph ie. a coloring of the hyperedges of a simple hypergraph, such that no two adjacent hyperedges share the same color. Colors are as always represented as integers.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{EFLResult(graph: SimpleHyperGraph, heuristic: EFLHeuristic)} \newline
			A constructor for this class \newline
			\textbf{@param graph} the graph this result was calculated upon \newline
			\textbf{@param heuristic} the heuristic this result was calculated by
		}
		\item{
			\textbf{getEdgeColor(edge: SimpleHyperEdge): int} \newline
			\textbf{@param edge} the edge whose color is requested \newline
			\textbf{@return} returns the color of \textbf{edge} \newline
			\textbf{@throws DataInconsistencyException} if edge has no color
		}
		\item{
			\textbf{setEdgeColor(edge: SimpleHyperEdge, color: int)} \newline
			\textbf{@param edge} the edge to be colored \newline
			\textbf{@param color} the color to color \textbf{edge} with
		}
	\end{enumerate}
	
	~\newpage
	
	\myclass{EFLData}
	
	\textbf{Description}
	
	This abstract class encapsulates the data required temporarly to calculate a EFL-coloring, such as the lists of \textbf{free colors} of uncolored edges (ie. the colors which are not used by other objects adjacent / incident to them). Moreover it stores how often colors are used.
	
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{EFLData(graph: SimpleHyperGraph)} \newline
			A constructor of this class \newline
			\textbf{@param graph} the graph the heuristic is running at
		}
		\item{
			\textbf{\textit{init()}} \newline
			May be implemented to (re-)initialize the data at any time within the running heuristic
		}
		\item{
			\textbf{\textit{justColoredEdge(edge: SimpleHyperEdge)}} \newline
			May be implemented to update data anytime when an edge was colored \newline
			\textbf{@param edge} the edge which was just colored
		}
		\item{
			\textbf{removeFreeColor(edge: SimpleUndirectedEdge, color: int)} \newline
			\textbf{@param edge} the edge which will have one free color less \newline
			\textbf{@param color} the color which \textbf{edge} mustnt use
		}
		\item{
			\textbf{getFlex(edges: List<SimpleUndirectedEdge>): int} \newline
			\textbf{@param vertices} the set of vertices whose flexibility should be calculated \newline
			\textbf{@return} returns the flexibility of these vertices ie. \# of colors which are free for all edges -- \# of \textbf{edges}
		}
		\item{
			\textbf{getColorWeight(color: int): int} \newline
			\textbf{@param color} the color whose weight is requested \newline
			\textbf{@return} returns the weight of this color ie. how often it was used weighted differently by vertices and edges
		}
		\item{
			\textbf{setColorWeight(color: int, weight: int)} \newline
			\textbf{@param color} the color whose weight will be updated \newline
			\textbf{@param weight} the new weight of \textbf{color}
		}
		\item{
			\textbf{getFreeVertexColors(edge: SimpleUndirectedEdge): List<int>} \newline
			\textbf{@param edge} the edge whose free colors are requested \newline
			\textbf{@return} returns the list of free colors of \textbf{edge}
		}
	\end{enumerate}
	
	
	~\newpage
	
	\myclass{EFLFlexSet}
	
	\textbf{Description}
	
	This class represents a subset of edges of a graph with a given \textbf{flexibility value} (ie. \# colors free for all edges -- \# edges) used heavily in some EFLHeuristics.
	
	\textbf{Documentation}
	\begin{enumerate}[\#]
		\item{
			\textbf{EFLFlexSet(edges: List<SimpleHyperEdge>, value: int)} \newline
			A constructor of this class \newline
			\textbf{@param edges} some edges \newline
			\textbf{@param value} the flexibility value of \textbf{edges}
		}
		\item{
			\textbf{getEdges(): List<SimpleHyperEdge>} \newline
			\textbf{@return} returns the edges in this flex set
		}
		\item{
			\textbf{getValue(): int} \newline
			\textbf{@return} returns the flexibility value of this set of objects
		}
	\end{enumerate}
	
	
	
	
	~\newpage
	
	\mypackage{heuristic.erdosFaberLovasz.greedy}
	In this package some heuristics for the Erdös Faber Lovasz conjecture are implemented. They behave  like the edge coloring part of the TCGreedy- heuristics.
	
	TODO eflgreedy.png UML
	
	\myclass{EFLGreedyData}
	
	\textbf{Description}
	
	Since EFLData is abstract this class is required such that the EFLGreedy heuristic has its own data class, even if with respect to EFLData no additional attributes or methods are added.
	
	~\newline
	~\newline
	~\newline
	
	\myclass{EFLGreedy}
	
	\textbf{Description}
	
	This class implements the EFLGreedy heuristic which tries to calculate a proper hyperedge coloring as specified in the addendum.
	
	\textbf{Documentation}
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleHyperGraph): EFLResult} \newline
			\textbf{@param graph} the graph this heuristic will be applied on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{EFLGreedyOneData}
	
	\textbf{Description}
	
	This class stores all uncolored edges with exactly one free color temporarily.
	
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{init()} \newline
			initializes the list of all uncolored edges with exactly one free color
		}
		\item{
			\textbf{justColoredEdge(edge: SimpleHyperEdge)} \newline
			updates the list of edges with exactly one free color \newline
			\textbf{@param edge} the edge which was just colored
		}
		\item[-]{
			\textbf{calcSingularEdges()} \newline
			updates the list of edges with exactly one free color
		}
		\item{
			\textbf{getMinimalSingularEdge(): SimpleUndirectedEdge} \newline
			\textbf{@return} returns the minimal edge with exactly one free color with respect to the order defined on edges
		}
	\end{enumerate}
	
	
	
	\myclass{EFLGreedyOne}
	
	\textbf{Description}
	
	This class implements the EFLGreedyOne heuristic which tries to calculate a hyperedge coloring as specified in the addendum.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleHyperGraph): EFLResult} \newline
			\textbf{@param graph} the graph this heuristic will be calculated on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{EFLGreedyFewData}
	
	\textbf{Description}
	
	This class stores all uncolored edges sorted first by their amount of free colors and then by the order defined on edges.
	
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{init()} \newline
			initializes the list of uncolored edges
		}
		\item{
			\textbf{justColoredEdge(edge: SimpleHyperEdge)} \newline
			updates the list of uncolored edges
		}
		\item{
			\textbf{getMinimalUncoloredEdge(): SimpleUndirectedEdge} \newline
			\textbf{@return} returns the minimal uncolored edge with respect to the number of free colors and the order defined on edges
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{EFLGreedyFew}
	
	\textbf{Description}
	
	This class implements the EFLGreedyFew heuristic, which tries to calculate a hyperedge coloring as specified in the addendum.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleHyperGraph): EFLResult} \newline
			\textbf{@param graph} the graph this heuristic will be calculated on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	~\newpage
	
	\myclass{EFLGreedySetData}
	
	\textbf{Description}
	
	This class stores for any vertex v the subset of all uncolored hyperedges incident to v which has the lowest flexibility value (ie. \# of colors which are free for every edge in this set -- \# of edges in the set) and is the lowest with respect to lexicographic ordering using the order defined on edges. These sets are from now on referred to as minimal flex sets
		
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{init()} \newline
			initializes the minimal flex sets
		}
		\item{
			\textbf{justColoredEdge(edge: SimpleHyperEdge)} \newline
			updates the minimal flex sets of the vertices incident to edge
		}
		\item[-]{
			\textbf{calcMinimalFlexSet(vertex: int)} \newline
			calculates the minimal flex set of \textbf{vertex} \newline
			\textbf{@param vertex} the vertex whose minimal flex set is calculated
		}
		\item{
			\textbf{getMinimalFlexSet(): EFLFlexSet} \newline
			\textbf{@return} returns the minimal flex set belonging to the vertex with minimal index
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{EFLGreedySet}
	
	\textbf{Description}
	
	This class implements the EFLGreedySet heuristic, which tries to calculate a hyperedge coloring as specified in the addendum.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleHyperGraph): EFLResult} \newline
			\textbf{@param graph} the graph this heuristic will be calculated on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	~\newpage
	
	\myclass{EFLGreedyConData}
	
	\textbf{Description}
	
	This class stores the list of uncolored edges temporarily to compute connected subsets of uncolored edges up to a specific size.
		
	\textbf{Documentation}
	
	\begin{enumerate}[\#]
		\item{
			\textbf{init()} \newline
			initializes the list of uncolored edges
		}
		\item{
			\textbf{justColoredEdge(edge: SimpleHyperEdge)} \newline
			updates the list of uncolored edges
		}
		\item{
			\textbf{getMinimalFlexSet(): EFLFlexSet} \newline
			\textbf{@return} returns the connected set of uncolored edges with minimal flexibility value (\# of colors which are free for all edges -- \# of edges) and minimal lexicographic order using the order defined on edges.
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{EFLGreedyCon}
	
	This class implements the EFLGreedyCon heuristic, which tries to calculate a hyperedge coloring as specified in the addendum.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{applyTo(graph: SimpleHyperGraph): EFLResult} \newline
			\textbf{@param graph} the graph this heuristic will be calculated on \newline
			\textbf{@return} returns the calculated coloring
		}
	\end{enumerate}
	
	
	
	
	~\newpage
	
	\section{View}
	\section{Controller}
	\section{Input-Output}
	
	~\newpage
	\section{Utils}
	
	In this package some helpful classes are implemented.
	TODO utils.png UML
	
	\myclass{Properties}
	
	\textbf{Description}
	
	This abstract class implements a key value storage used for exchanging data between the different layers of the application. It is used to adapt the user interface to varying settings of heuristics. The keys may be used to translate the GUI to different languages as well. New key-value pairs can only be added by subclasses, thus guaranteeing their presence at any time.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{getProperties(): List<String>} \newline
			\textbf{@return} returns the list of all keys ie. properties
		}
		\item[\#]{
			\textbf{addProperty(property: String, value: PropertyValue)} \newline
			\textbf{@param property} the property to be added \newline
			\textbf{@param value} the value(-type) the property will have \newline
			\textbf{@throws DataInconsistencyException} if the property is already set
		}
		\item{
			\textbf{getProperty(property: String): PropertyValue} \newline
			\textbf{@param property} the property whose value is requested \newline
			\textbf{@return} returns the value of the property \newline
			\textbf{@throws DataInconsistencyException} if there is no key \textbf{property}
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{PropertyValue}
	
	\textbf{Description}
	
	This class stores data of the type \textbf{T}, which might be constant.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{PropertyValue(value: T, const: bool)} \newline
			A constructor of this class \newline
			\textbf{@param value} the value of this PropertyValue \newline
			\textbf{@param const} whether the value is constant ie. might not be altered after its initialization
		}
		\item{
			\textbf{getValue(): T} \newline
			\textbf{@return} returns the value stored in this PropertyValue
		}
		\item{
			\textbf{setValue(value: T)} \newline
			\textbf{@param value} the value which will be stored in this PropertyValue \newline
			\textbf{@throws DataInconsistencyException} if the const flag is set
		}
		\item{
			\textbf{isConstant(): bool} \newline
			\textbf{@return} returns \textbf{true} iff this PropertyValue is constant ie. the const flag is set
		}
	\end{enumerate}
	
	~\newpage
	
	\myclass{Language}
	
	\textbf{Description}
	
	This class stores language data ie. maps tokens to translations.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{Language(rageFormat: List<String>)} \newline
			\textbf{@param rageFormat} the line by line representation of a language / translation as specified in the RAGE data format
		}
		\item{
			\textbf{getText(identifier: String): String} \newline
			\textbf{@param identifier} the identifier of the translation \newline
			\textbf{@return} returns the translation corresponding to \textbf{identifier} or ''MISSING:\textbf{identifier}'' if there is no translation
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{Profiler}
	
	\textbf{Description}
	
	This class is used to gather statistics about timing.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{startMeasurement()} \newline
			starts measuring the time
		}
		\item{
			\textbf{endMeasurement()} \newline
			ends the running measurement and adds it to the collected data
		}
		\item{
			\textbf{getMinTime(): double} \newline
			\textbf{@return} returns the minimal time measured by this Profiler
		}
		\item{
			\textbf{getMaxTime(): double} \newline
			\textbf{@return returns the maximal time measured by this Profiler}
		}
		\item{
			\textbf{getAvgTime(): double} \newline
			\textbf{@return} returns the average time measured by this Profiler
		}
		\item{
			\textbf{getNumMeasurements(): int} \newline
			\textbf{@return} returns the number of measurements taken by this Profiler
		}
	\end{enumerate}
	
	~\newpage
	
	\myclass{Tuple}
	
	\textbf{Description}
	
	This class represents a tuple of two variables x and y of types \textbf{X} and \textbf{Y} respectively.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{Tuple(x: X, y: Y)} \newline
			A constructor of this class \newline
			\textbf{@param x} the first entry of this tuple \newline
			\textbf{@param y} the second entry of this tuple
		}
		\item{
			\textbf{getX():X} \newline
			\textbf{@return} returns the first component of this tuple
		}
		\item{
			\textbf{setX(x: X)} \newline
			\textbf{@param x} the value to be assigned to the first component of this tuple
		}
		\item{
			\textbf{getY():Y} \newline
			\textbf{@return} returns the second component of this tuple
		}
		\item{
			\textbf{setY(y: Y)} \newline
			\textbf{@param y} the value to be assigned to the second component of this tuple
		}
	\end{enumerate}
	
	~\newline
	~\newline
	~\newline
	
	\myclass{CollectionUtil}
	
	\textbf{Description}
	
	This class provides some helper methods for collections of elements of type \textbf{T} as finding minimal elements (of a cost function returning values of type \textbf{R}) or subsets.
	
	\textbf{Documentation}
	
	\begin{enumerate}[+]
		\item{
			\textbf{getMinimalValue(collection: Collection<T>, evaluation: Function<T,R>): R} \newline
			\textbf{@param collection} the collection on which \textbf{evaluation} will be minimized \newline
			\textbf{@param evaluation} the evaluation / cost function which will be minimized \newline
			\textbf{@return} returns the minimal value of \textbf{evaluation}
		}
		\item{
			\textbf{getMinimalArgument(collection: Collection<T>, evaluation: Function<T,R>, leq: bool): T} \newline
			\textbf{@param collection} the collection on which \textbf{evaluation} will be minimized \newline
			\textbf{@param evaluation} the evaluation / cost function which will be minimized \newline
			\textbf{@param leq} if \textbf{false} the first entry in the collection minimizing \textbf{evaluation} will be returned, otherwise the last one will be returned \newline
			\textbf{@return} returns the argument minimalizing \textbf{evaluation}
		}
		\item{
			\textbf{getMinimalArgumentValue(collection: Collection<T>, evaluation: Function<T,R>, leq: bool): Tuple<T,R>} \newline
			\textbf{@param collection} the collection on which \textbf{evaluation} will be minimized \newline
			\textbf{@param evaluation} the evaluation / cost function which will be minimized \newline
			\textbf{@param leq} if \textbf{false} the first entry in the collection minimizing \textbf{evaluation} will be returned, otherwise the last one will be returned \newline
			\textbf{@return} returns the tuple (argument, value) minimalizing \textbf{evaluation}
		}
		\item{
			\textbf{getSubCollections(collection: Collection<T>): List<Collection<T>>} \newline
			\textbf{@param collection} the collection whose subcollections shall be retrieved \newline
			\textbf{@return} returns the list of subcollections of \textbf{collection} (in lexicographic order, if \textbf{collection} is sorted)
		}
		\item{
			\textbf{getSubCollections(collection: Collection<T>, minSize: int, maxSize: int): List<Collection<T>>} \newline
			\textbf{@param collection} the collection whose subcollections shall be retrieved \newline
			\textbf{@param minSize} the minimal size of the subcollections returned \newline
			\textbf{@param maxSize} the maximal size of the subcollections returned \newline
			\textbf{@return} returns the list of subcollections of \textbf{collection} (in lexicographic order, if \textbf{collection} is sorted) of size between \textbf{minSize} and \textbf{maxSize}
		}
	\end{enumerate}
	
	
	
	~\newpage
	
	\section{Addendum: Heuristiken}
	\subsection{Einleitung}
	Im folgenden werden die implementierten Heuristiken erklärt. Im Wesentlichen gibt es zwei Familien von Heuristiken: die TCHeuristiken und die EFLHeuristiken.
	
	Erstere behandeln das \textbf{Total Coloring Conjecture}. Dieses besagt, dass jeder einfache ungerichtete Graph mit Maximalgrad $\Delta$ eine valide Totalfärbung mit $\Delta+2$ Farben besitzt. Dabei ist ein \textbf{einfacher ungerichteter Graph} ein Graph, in dem Kanten immer genau zwei verschiedene Knoten verbinden, die Reihenfolge dieser Knoten nicht relevant ist und es nicht mehrere Kanten zwischen zwei Knoten gibt. Der \textbf{Grad} eines Knoten eines solchen Graphen ist die Anzahl der zu ihm inzidenten Kanten. Eine valide \textbf{Totalfärbung} ist eine Färbung der Knoten und Kanten eines solchen Graphen, sodass keine zwei zueinander adjazente Knoten, adjazente Kanten oder inzidente Knoten und Kanten dieselbe Farbe besitzen. 
	
	Zweitere behandeln das \textbf{Erdös Faber Lovasz Conjecture}. Es besagt, dass jeder einfache Hypergraph auf $n$ Knoten eine valide Kantenfärbung mit $n$ Farben besitzt. Dabei ist ein \textbf{Hypergraph} ein Graph, dessen (Hyper-)Kanten beliebige Teilmengen der Knotenmenge darstellen. Ein solcher Graph heißt \textbf{einfach}, wenn alle Kanten mindestens zwei Knoten umfassen und es keine zwei Kanten gibt, die mehr als einen Knoten gemeinsam haben. Eine \textbf{Kantenfärbung} ist eine Färbung der Hyperkanten dergestalt, dass keine zwei adjazente Hyperkanten dieselbe Farbe zugewiesen haben.
	
	Die \textbf{freien Farben} $\mathcal F(v)$ eines Knotens bzw. $\mathcal F(e)$ einer Kante sind all die Farben, die nicht von einem dazu adjazenten oder inzidenten Objekt belegt sind. Die \textbf{Flexibilität} einer Menge $X$ von Knoten und Kanten ist die Anzahl der Farben, die für jedes Objekt frei sind, minus der Anzahl der Objekte, d.h. $\# \bigcap \limits_{x \in X} \mathcal F(x) - \# X$. Negative Flexibilität bedeutet insbesondere, dass die Menge $X$ nicht gefärbt werden kann.
	
	Grundlegend für die Arbeitsweise der Heuristiken ist die inhärente Ordnung der Knoten gegeben über ihre Indizes. Auf einfachen ungerichteten Kanten und Hyperkanten wird dadurch eine \textbf{lexikographische Ordnung} induziert, indem man sie als geordnete Tupel von Knotenindizes auffasst. Es gilt dann z.B. $(1,2) < (1,4) < (2, 3) < (2,3,4)$.
	
	Um eine möglichst gleichmäßige Färbung zu erzeugen zählen die Heuristiken mit, wie oft einzelne Farben benutzt worden sind, gewichtet nach der Anzahl der gefärbten Knoten und der gefärbten Kanten. Konkret bedeutet das, dass die Anzahl der mit einer bestimmten Farbe $c$ gefärbten Knoten $V(c)$ eine andere Gewichtung $\omega_v$ haben kann als die Gewichtung $\omega_e$ der mit dieser Farbe gefärbten Kanten $E(c)$. Das Gewicht einer Farbe wird demnach durch $\# V(c) \cdot \omega_v + \# E(c) \cdot \omega_e$ bestimmt. Da Farben ebenso wie Knoten mit einer natürlichen Zahl identifiziert werden, gibt es stets eine eindeutige Farbe minimaler Gewichtung und minimalem Index. Diese wird im Folgenden nur mit \textbf{minimal benutzter Farbe} bezeichnet.
	
	Die in den folgenden Heuristiken auftretende \textbf{Breitensuche} startet stets im Knoten mit minimalem Index. Für jeden Knoten werden wie bei einer Breitensuche üblich alle noch unberührten Nachbarn nach ihren Indizes sortiert inspiziert. Sollte der Graph nicht zusammenhängend sein, wird immer der kleinste unberührte Knoten als neuer Startpunkt genommen.
	
	
	~\newpage
	\subsection{TCGreedy}
	
	\textbf{Beschreibung}
	
	Diese Heuristik färbt zuerst die Knoten mithilfe einer Breitensuche. Anschließend färbt sie (ebenfalls in der Reihenfolge einer Breitensuche) der Reihe nach alle Kanten inzident zu einem gemeinsamen Knoten.
	
	\textbf{Pseudocode}
	\begin{verbatim}
		for every vertex v in order of a breadth first search
		    if v cannot be colored
		        return incomplete coloring
		    get minimally used free color c of v with respect to the color weights
		    color v with color c
				    
		for every vertex v in order of a breadth first search
		    for every uncolored edge e incident to v in the order defined on edges
		        if e cannot be colored
		            return incomplete coloring
		        get minimally used free color c of e with respect to the color weights
		        color e with color c
				        
		return complete coloring
	\end{verbatim}
	
	\subsection{TCGreedyOne}
	
	\textbf{Beschreibung}
	
	Diese Heuristik färbt zuerst die Knoten mithilfe einer Breitensuche. Anschließend färbt sie der Reihe nach alle Kanten inzident zu einem gemeinsamen Knoten  (ebenfalls in der Reihenfolge einer Breitensuche). Wenn es jedoch Kanten gibt, die genau eine freie Farbe haben, werden diese bevorzugt koloriert.
	
	\textbf{Pseudocode}
	\begin{verbatim}
		for every vertex v in the order of a breadth first search
		    if v cannot be colored
		        return incomplete coloring
		    get minimally used free color c of v with respect to the color weights
		    color v with color c
				    
		for every vertex v in the order of a breadth first search
		    for every uncolored edge e incident to v in the order defined on edges
		        while there are uncolored edges with exactly one free color
		            get uncolored edge with exactly one free color f which is minimal with respect to 
		            the order given on edges
		            color f with its unique free color
		            
		        if e is colored already
		            continue
		        if e cannot be colored
		            return incomplete coloring
		        get minimally used free color c of e with respect to the color weights
		        color e with color c
				        
		return complete coloring
	\end{verbatim}
		
	\subsection{TCGreedyFew}
	
	\textbf{Beschreibung}
	
	Diese Heuristik färbt zuerst die Knoten mithilfe einer Breitensuche. Anschließend färbt sie der Reihe nach alle Kanten inzident zu einem gemeinsamen Knoten(ebenfalls in der Reihenfolge einer Breitensuche). Wenn es jedoch Kanten gibt, die weniger freie Farben haben, als die aktuell zu kolorierende, werden diese bevorzugt gefärbt.
	
	\textbf{Pseudocode}
	\begin{verbatim}
		for every vertex v in the order of a breadth first search
		    if v cannot be colored
		        return incomplete coloring
		    get minimally used free color c of v with respect to the color weights
		    color v with color c
				    
		for every vertex v in the order of a breadth first search
		    for every uncolored edge e incident to v in the order defined on edges
		        while there are uncolored edges with less free colors than e and lower order than e
		            get such uncolored edge f which is minimal with respect to the order given on edges
		            if f cannot be colored
		                return incomplete coloring
		            get minimally used free color c of f with respect to the color weights
		            color f with color c
		            
		        if e is colored already
		            continue
		        if e cannot be colored
		            return incomplete coloring
		        get minimally used free color c of e with respect to the color weights
		        color e with color c
				        
		return complete coloring
	\end{verbatim}
	
	~\newpage
	
	\subsection{TCGreedySet}
	
	\textbf{Beschreibung}
	
	Diese Heuristik färbt zuerst die Knoten mithilfe einer Breitensuche. Anschließend färbt sie die Kanten durch auffinden derjenigen Teilmenge von Kanten inzident zu einem gemeinsamen Knoten, die minimale Flexibilität besitzt und bezüglich lexikographischer Ordnung minimal ist.
	
	\textbf{Pseudocode}
	\begin{verbatim}
		for every vertex v in the order of a breadth first search
		    if v cannot be colored
		        return incomplete coloring
		    get minimally used free color c of v with respect to the color weights
		    color v with color c
				    
		while there is a set with minimal flexibility
		    find the set X of minimal flexibility belonging to one vertex and with lowest lexicographic 
		    order
		    if X has negative flexibility
		        return incomplete coloring
		        
		    for every edge e of X in the order defined on edges
		        if e cannot be colored
		            return incomplete coloring
		        get minimally used free color c of e with respect to the color weights
		        color e with color c
				        
		return complete coloring
	\end{verbatim}
	
	~\newpage
	
	\subsection{TCGreedyCon}
	
	\textbf{Beschreibung}
	
	Diese Heuristik färbt zuerst die Knoten mithilfe einer Breitensuche. Anschließend färbt sie die Kanten durch auffinden derjenigen Teilmenge von zusammenhängenden Kanten, die minimale Flexibilität besitzt und bezüglich lexikographischer Ordnung minimal ist. Die Größe dieser zusammenhängenden Teilmengen kann dabei nach oben beschränkt sein.
	
	\textbf{Pseudocode}
	\begin{verbatim}
		for every vertex v in the order of a breadth first search
		    if v cannot be colored
		        return incomplete coloring
		    get minimally used free color c of v with respect to the color weights
		    color v with color c
				    
		while there is a set with minimal flexibility
		    find the set X of minimal flexibility which has the lowest lexicographic order
		        if X has negative flexibility
		            return incomplete coloring
		            
		        for every edge e of X in the order defined on edges
		            if e cannot be colored
		                return incomplete coloring
		            get minimally used free color c of e with respect to the color weights
		            color e with color c
				        
		return complete coloring
	\end{verbatim}	
	
	
	~\newpage
	
	\subsection{TCMixedGreedy}
	
	\textbf{Beschreibung}
	
	Diese Heuristik nutzt eine Breitensuche, um von Knoten zu Knoten zu kommen. Sie färbt stets zunächst den Knoten und anschließend alle dazu inzidenten Kanten, bevor sie sich dem nächsten Knoten annimmt.
	
	\textbf{Pseudocode}
	\begin{verbatim}
		for every vertex v in order of a breadth first search
		    if v cannot be colored
		        return incomplete coloring
		    get minimally used free color c of v with respect to the color weights
		    color v with color c
				    
		    for every uncolored edge e incident to v in the order defined on edges
		        if e cannot be colored
		            return incomplete coloring
		        get minimally used free color c of e with respect to the color weights
		        color e with color c
				        
		return complete coloring
	\end{verbatim}
			
	~\newpage
	
	\subsection{TCMixedGreedyOne}
	
	\textbf{Beschreibung}
	
	Diese Heuristik nutzt eine Breitensuche, um von Knoten zu Knoten zu kommen. Sie färbt stets den Knoten und anschließend alle dazu inzidententen Kanten, es sei denn es gibt unkolorierte Knoten oder Kanten, die genau eine freie Farbe haben. Diese werden stets bevorzugt koloriert, wobei Knoten den Kanten vorgezogen werden.
	
	\textbf{Pseudocode}
	\begin{verbatim}
		for every vertex v in order of a breadth first search
		    while there are objects with exactly one free color
		        if there are vertices with exactly one free color
		            get the vertex w with exactly one free color and minimal index
		            color w with its unique free color
			        else
		            get the edge f with exactly one free color which is minimal with respect to the order
		            defined on edges
		            color f with its unique free color
		
		    if v is not colored yet
		        if v cannot be colored
		            return incomplete coloring
		        get minimally used free color c of v with respect to the color weights
		        color v with color c
			    
		    for every uncolored edge e incident to v in the order defined on edges
		        while there are objects with exactly one free color
		            if there are vertices with exactly one free color
		                get the vertex w with exactly one free color and minimal index
		                color w with its unique free color
		            else
		                get the edge f with exactly one free color which is minimal with respect to the order 
		                defined on edges
		                color f with its unique free color
				    
		        if e is not colored yet
		            if e cannot be colored
		                return incomplete coloring
		            get minimally used free color c of e with respect to the color weights
		            color e with color c
				        
		return complete coloring
	\end{verbatim}
	
	~\newpage
	
	\subsection{TCMixedGreedyFew}
	
	\textbf{Beschreibung}
	
	Diese Heuristik nutzt eine Breitensuche, um von Knoten zu Knoten zu kommen. Sie färbt stets zunächst den Knoten, falls es keine anderen unkolorierten Knoten mit weniger freien Farben und geringerem Index gibt, die bevorzugt zu behandeln sind. Anschließend färbt sie alle Kanten inzident zu dem Knoten, falls es keine unkolorierten Kanten mit weniger freien Farben und geringerer Ordnung gibt, die zu bevorzugen sind.
	
	\textbf{Pseudocode}
	\begin{verbatim}
		for every vertex v in order of a breath first search
		    while there is a vertex w with less free colors than v and lower index
		        if w cannot be colored
		            return incomplete coloring
		        get minimally used free color c of w with respect to the color weights
		        color w with color c
		    
		    if v is not colored yet
		        if v cannot be colored
		            return incomplete coloring
		        get minimally used free color c of v with respect to the color weights
		        color v with color c
		    
		    for every uncolored edge e incident to v in the order defined on edges
		        while there is an edge f with less free colors than e and lower order
		            if f cannot be colored
		                return incomplete coloring
		            get minimally used free color c of f with respect to the color weights
		            color f with color c
		           
		        if e is not colored yet    
		            if e cannot be colored
		                return incomplete coloring
		            get minimally used free color c of e with respect to the color weights
		            color e with color c
		    
		return complete coloring
	\end{verbatim}
	
	~\newpage
	\subsection{TCMixedGreedySet}
	
	\textbf{Beschreibung}
	
	Diese Heuristik sucht Teilmengen von Kanten inzident zu einem gemeinsamen Knoten, die minimale Flexibilität hat und bezüglich lexikographischer Ordnung minimal ist. Sollte der gemeinsame Knoten unkoloriert sein, werden Varianten mit dem Knoten und ohne den Knoten betrachtet, wobei letztere bevorzugt wird. Besagte Teilmenge minimaler Flexibilität wird dann koloriert.
	
	\textbf{Pseudocode}
	\begin{verbatim}
		while there are uncolored vertices or edges
		    find set X of minimal flexibility with lowest lexicographic order incident to a vertex v
		        if X has negative flexibility
		            return incomplete coloring
		            
		        if v is uncolored and contained in X
		            if v cannot be colored
		                return incomplete coloring
		            get minimally used free color c of v with respect to the color weights
		            color v with color c
		        
		        for every edge e in X
		            if e cannot be colored
		                return incomplete coloring
		            get minimally used free color c of v with respect to the color weights
		            color e with color c
		
		return complete coloring
	\end{verbatim}
	
	~\newpage
	\subsection{TCMixedGreedyCon}
	
	\textbf{Beschreibung}
	
	Diese Heuristik sucht unter denjenigen Menge zusammenhängender Kanten, und zu ihnen inzidenten Knoten, die minimale Flexibilität und minimale lexikographische Ordnung hat. Dabei werden zunächst die Kanten verglichen und erst am Ende die Knotenmengen, aufgefasst als Hyperkanten. Die Anzahl der Kanten in einer solchen Menge kann dabei nach oben beschränkt sein.
	
	\textbf{Pseudocode}
	\begin{verbatim}
		while there are uncolored vertices or edges
		    find connected set X of minimal flexibility and minimal lexicographic order
		    if X has negative flexibility
		        return incomplete coloring
		    
		    for every vertex v in X
		        if v cannot be colored
		            return incomplete coloring
		        get minimally used free color c of v with respect to the color weights
		        color v with color c
		        
		    for every edge e in X
		        if e cannot be colored
		            return incomplete coloring
		        get minimally used free color c of e with respect to the color weights
		        color e with color c
		       
		return complete coloring
	\end{verbatim}
	
	~\newpage
	\subsection{EFLGreedy}
	
	\textbf{Beschreibung}
	
	Diese Heuristik färbt (in der Reihenfolge einer Breitensuche) der Reihe nach alle Hyperkanten inzident zu einem gemeinsamen Knoten.
	
	\textbf{Pseudocode}
	\begin{verbatim}    
		for every vertex v in order of a breadth first search
		    for every uncolored edge e incident to v in the order defined on edges
		        if e cannot be colored
		            return incomplete coloring
		        get minimally used free color c of e with respect to the color weights
		        color e with color c
				        
		return complete coloring
	\end{verbatim}
	
	~\newline
	~\newline
	
	\subsection{EFLGreedyOne}
	
	\textbf{Beschreibung}
	
	Diese Heuristik färbt (in der Reihenfolge einer Breitensuche) der Reihe nach alle Hyperkanten inzident zu einem gemeinsamen Knoten, wenn es grad keine Hyperkanten gibt, die genau eine freie Farbe haben. Letztere werden bevorzugt koloriert.
	
	\textbf{Pseudocode}
	\begin{verbatim}    
		for every vertex v in the order of a breadth first search
		    for every uncolored edge e incident to v in the order defined on edges
		        while there are uncolored edges with exactly one free color
		            get uncolored edge with exactly one free color f which is minimal with respect to 
		            the order given on edges
		            color f with its unique free color
		            
		        if e is colored already
		            continue
		        if e cannot be colored
		            return incomplete coloring
		        get minimally used free color c of e with respect to the color weights
		        color e with color c
				        
		return complete coloring
	\end{verbatim}
	
	~\newpage
	\subsection{EFLGreedyFew}
	
	\textbf{Beschreibung}
	
	Diese Heuristik färbt der Reihe nach alle Hyperkanten inzident zu einem gemeinsamen Knoten (in der Reihenfolge einer Breitensuche). Wenn es Hyperkanten gibt, die weniger freie Farben haben, werden diese bevorzugt koloriert.
	
	\textbf{Pseudocode}
	\begin{verbatim}  
		for every vertex v in the order of a breadth first search
		    for every uncolored edge e incident to v in the order defined on edges
		        while there are uncolored edges with less free colors than e and lower order than e
		            get such uncolored edge f which is minimal with respect to the order given on edges
		            if f cannot be colored
		                return incomplete coloring
		            get minimally used free color c of f with respect to the color weights
		            color f with color c
		            
		        if e is colored already
		            continue
		        if e cannot be colored
		            return incomplete coloring
		        get minimally used free color c of e with respect to the color weights
		        color e with color c
				        
		return complete coloring
	\end{verbatim}
	
	~\newline
	~\newline
	
	\subsection{EFLGreedySet}
	
	\textbf{Beschreibung}
	
	Diese Heuristik färbt die Hyperkanten durch auffinden derjenigen Teilmenge von Hyperkanten inzident zu einem gemeinsamen Knoten, die minimale Flexibilität besitzt und bezüglich lexikographischer Ordnung minimal ist.
	
	\textbf{Pseudocode}
	\begin{verbatim}  
		while there is a set with minimal flexibility
		    find the set X of minimal flexibility belonging to one vertex and with lowest lexicographic 
		    order
		    if X has negative flexibility
		        return incomplete coloring
		        
		    for every edge e of X in the order defined on edges
		        if e cannot be colored
		            return incomplete coloring
		        get minimally used free color c of e with respect to the color weights
		        color e with color c
				        
		return complete coloring
	\end{verbatim}
	
	~\newpage
	
	\subsection{EFLGreedyCon}
	
	\textbf{Beschreibung}
	
	Diese Heuristik färbt die Hyperkanten durch auffinden derjenigen Teilmenge von zusammenhängenden Hyperkanten, die minimale Flexibilität besitzt und bezüglich lexikographischer Ordnung minimal ist. Die Größe dieser zusammenhängenden Teilmengen kann dabei nach oben beschränkt sein.
	
	\textbf{Pseudocode}
	\begin{verbatim}    
		while there is a set with minimal flexibility
		    find the set X of minimal flexibility which has the lowest lexicographic order
		        if X has negative flexibility
		            return incomplete coloring
		            
		        for every edge e of X in the order defined on edges
		            if e cannot be colored
		                return incomplete coloring
		            get minimally used free color c of e with respect to the color weights
		            color e with color c
				        
		return complete coloring
	\end{verbatim}	
	
	
	
	~\newpage
	\section{Addendum: RAGE-Datenformate}
	\subsection{Graphen}
	Graphen werden wie folgt im Textformat gespeichert: \newline
	Die erste Zeile enthält den Typ des Graphen und die zweite Zeile lediglich eine Ganzzahl, die die Anzahl der Knoten speichert. Es folgen Zeile für Zeile die Kanten, dargestellt als aufeinanderfolgende, aufsteigend sortierte Ganzzahlen.
	
	\subsection{Properties}
	Properties werden wie folgt im Textformat gespeichert: \newline
	Die erste Zeile enthält den konkreten Typ der Properties-Klasse. Ab der zweiten Zeile werden zeilenweise die einzelnen Properties im Format \texttt{property value:type} gespeichert.
	
	\subsection{Heuristiken}
	Die Heuristiken speichern neben ihren Properties nur ihren Namen.
	
\end{document}