class Graph:
	int numVerts;

	abstract HashMap<Int, HashSet<Int>> getNeighborhoods();

class Edge:
	int v;
	int w;

class TotalColoring:
	bool valid;
	HashMap<Int, Color> vertexColors;
	HashMap<Edge, Color> edgeColors;

class GreedyHeuristic extends Heuristic<SimpleUndirectedGraph, TotalColoring>:
	const int vertexWeight;
	const int edgeWeight;
	const int numColors;


	// find minimal color in list of colors given certain weights
	Color minimum(List<Color> colors, HashMap<Color, Int> weights):
		color = colors[0];
		weight = weights[0]

		for c in colors:
			if weights[c] < weight:
				color = c;
				weight = weights[c]

		return color;


	// overrides T apply(G g) of Heuristic<G,T>
	TotalColoring apply(SimpleUndirectedGraph g):
		TotalColoring coloring;

		HashMap<Color, Int> colorWeights;
		HashMap<Int, List<Color>> freeVertexColors;
		HashMap<Edge, List<Color>> freeEdgeColors;
		HashMap<Int, OrderedList<Int>> neighborhood;

		// use bfs to step through vertices
		int v = 0;
		bfs = BFS(g, 0); // Breadth First Search on G starting at vertex v

		// color vertex for vertex
		while bfs.hasNext():
			if freeVertexColors[v].isEmpty():
				coloring.valid = false;
				return coloring;
			
			// find minimal used free color of v
			c = minimum(freeVertexColors[v], colorWeights)

			// color v with this color
			coloring.vertexColors[v] = c

			// update the color's weight
			colorWeights[c] += vertexWeight;

			// remove c from free colors of v's neighbours and edges incident to v
			for w in neighborhood[v]:
				freeVertexColors[w].remove(c);
				freeEdgeColors[vw].remove(c);

			// color next vertex
			v = bfs.next()

		//restart bfs
		v = 0;
		bfs = BFS(g,v);
				
		// color edges vertex for vertex
		while bfs.hasNext():
			// color all edges incident to v
			for w in neighborhood[v] where not coloring.edgeColors.contains(vw):
				if freeEdgeColors[vw].isEmpty():
					coloring.valid = false;
					return coloring;

				// find minimal used free color of vw
				c = minimum(freeEdgeColors[vw], colorWeights)
				
				// color vw with this color
				coloring.edgeColor[vw] = c

				// update colors weight
				colorWeights[c] += edgeWeight

				//remove c from free colors of adjacent edges
				for x in neighborhood[v] where x != w:
					freeEdgeColors[vx].remove(c)

				for y in neighborhood[w] where y != v:
					freeEdgeColors[wy].remove(c)			

			// goto next vertex
			v = bfs.next()

		// total coloring successful calculated
		coloring.valid = true;
		return coloring
					






		