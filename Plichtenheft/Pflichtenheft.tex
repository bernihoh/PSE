\documentclass{article}

\usepackage[margin=2.5cm]{geometry}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}

\usepackage{hyperref}
\hypersetup{
pdftitle={Pflichtenheft},
bookmarks = true
}
\usepackage[toc]{glossaries}

\usepackage{graphicx}

\usepackage[shortlabels]{enumitem}
\usepackage{parskip}

\usepackage{float}
\floatplacement{figure}{H}
\usepackage{placeins}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{fix-cm}
\newcommand{\titlesize}{\fontsize{30pt}{20pt}\selectfont}
\newcommand{\themesize}{\fontsize{20pt}{20pt}\selectfont}
\newcommand{\authorsize}{\fontsize{15pt}{20pt}\selectfont}


\makeglossaries



%\titlehead{\centering \includegraphics{images/title}}
%\title{RaGE Pflichtenheft}
%\author{Jonas Kasper, Bernard Hohmann, Thomas Fischer, Christian Jung, Jonas Linßen}

\begin{document}
	%\maketitle
	
	%\newpage
	
	\begin{titlepage}
		\centering \includegraphics[width=0.7\textwidth]{images/title}
		
		\titlesize \hspace*{.5cm} Random Graph Coloring Evaluation
		~\newline~\newline
		
		\themesize \hspace*{3cm} Pflichtenheft
		\newline~\newline
		
		\authorsize Jonas Kasper, Bernard Hohmann, Thomas Fischer, Christian Jung, Jonas Linßen
	\end{titlepage}
	
	\tableofcontents
	
	\newpage
	
	
	\section{Zielbestimmung}
	Das Produkt ermöglicht dem Lehrstuhl IPD Böhm die automatische Generierung ungerichteter, einfacher Graphen sowie einfacher Hypergraphen und die automatisierte Evaluation verschiedener Heuristiken zur Lösung von bisher ungelösten Problemen der Informatik.
	
	\subsection{Musskriterien}
	\begin{enumerate}[(M1)]
		\item{Es können einfache, ungerichtete Graphen und einfache Hypergraphen nach durch den Nutzer spezifizierten Kriterien zufällig generiert werden.}
		\item{Auf die generierten Graphen können durch den Nutzer auszuwählende Heuristiken angewandt werden.}
		\item{Die Graphen und Ergebnisse der Heuristiken werden in einer graphischen Oberfläche angezeigt.}
		\item{Die Graphen können durch den Nutzer modifiziert werden, d.h. es können Knoten und Kanten hinzugefügt und gelöscht werden. Insbesondere ist es möglich Graphen von Hand zu zeichnen.}
		\item{Für die folgenden offenen Probleme sind Heuristiken implementiert:
			\begin{enumerate}[i)]
				\item{Total Coloring Conjecture}
				\item{Erdös Faber Lovasz Conjecture}
			\end{enumerate}
		}
	\end{enumerate}
	
	\subsection{Kannkriterien}
	\begin{enumerate}[(K1)]
		\item{Die folgenden Eigenschaften von Graphen können erkannt werden:
			\begin{enumerate}[i)]
				\item{Zusammenhang}
				\item{Baum}
				\item{Bipartition}
				\item{Planarität}
				\item{Intervallgraph / Chordalität}
			\end{enumerate}
			Die zufällige Generierung der Graphen lässt sich insbesondere auf eine Auswahl dieser Eigenschaften einschränken bzw. einige der genannten Eigenschaften können dabei ausgeschlossen werden.
		}
		\item{Weitere Heuristiken können als Plugins in das Programm eingebunden werden. Dies ermöglicht die Anwendung auf weitere ungelöste Probleme der Informatik.}
		\item{Die folgenden Sprachen werden unterstützt
			\begin{enumerate}[i)]
				\item{Deutsch}
				\item{Englisch}
			\end{enumerate}
		}
	\end{enumerate}
	
	\subsection{Abgrenzungskriterien}
	\begin{enumerate}
		\item[(A1)]{Die Heuristiken sind nicht an sich parallelisierbar.}
		\item[(A2)]{Es können keine gerichteten (Multi-)Graphen und keine allgemeinen Hypergraphen generiert werden.}
		\item[(A3)]{Bei der Generierung erfolgt keine Erkennung von Duplikaten. Die Erkennung von Graphenisomorphie ist \textbf{nicht} möglich.}
		\item[(A4)]{Das Programm kann weder für das Total Coloring Conjecture, noch für das Erdös Faber Lovasz Conjecture einen Beweis finden.}
	\end{enumerate}
	
	
	
	
	\section{Produkteinsatz}
	Das Produkt dient der Auswertung von Heuristiken für ungelöste Probleme der Graphentheorie auf möglichst vielen generierten Graphen.
	
	\subsection{Anwendungsbereiche}
	Das Programm ist für die Forschung in der Mathematik und Informatik, genauer der Graphentheorie, vorgesehen.
	
	\subsection{Zielgruppen}
	Das Produkt wird für die Nutzung im Lehrstuhl IPD Böhm am KIT entwickelt. Eine Anwendung in anderen Forschungseinrichtungen, Universitäten und Hochschulen sowie durch Privatpersonen mit Interesse an offenen Problemen der Graphentheorie ist möglich und erwünscht.
	
	\subsection{Betriebsbedingungen}
	Das Programm läuft auf Privat- und Betriebsrechnern (z.B. in einer Büroumgebung).
	
	
	
	\section{Produktumgebung}
	
	\subsection{Software}
	Die folgende Software ist für die Lauffähigkeit des Programms hinreichend:
	\begin{enumerate}[--]
		\item{Windows 10}
		\item{Java 8 Runtime Environment}
	\end{enumerate}
	Durch die Plattformunabhängigkeit der JRE ist auch eine Anwendung auf anderen Betriebssystemen möglich.
	
	\subsection{Hardware}
	Das Programm läuft auf Rechnern mit durchschnittlicher Rechenleistung. Es benötigt mindestens:
	\begin{enumerate}[--]
		\item{4GB Arbeitsspeicher}
		\item{4GB Festplattenspeicher}
		\item{Maus und ggf. Tastatur}
	\end{enumerate}
	
	
	
	\newpage
	\section{Funktionale Anforderungen}
	Die durch * markierten Einträge sind Kannkriterien und nur aus Vollständigkeitsgründen im Folgenden aufgeführt.
	
	\subsection*{/F10/ Zufällige Generierung von Graphen} \label{f10} \addcontentsline{toc}{subsection}{\nameref{f10}}
	
	\subsubsection*{/F11/ Voreinstellungen} \label{f11} \addcontentsline{toc}{subsubsection}{\nameref{f11}}
	
	Die folgenden Voreinstellungen können getroffen werden:
	\begin{enumerate}[i)]
		\item{Es kann ausgewählt werden, ob einfache ungerichtete Graphen (SGs) oder einfache Hypergraphen (SH) generiert werden sollen}
		\item{Die Anzahl der zu generierenden (Hyper-) Graphen kann eingestellt werden. Es werden zwischen 1 und 100 000 Graphen unterstützt.}
	\end{enumerate}
	
	\subsubsection*{/F12/ Einstellungen für Graphen} \label{f12} \addcontentsline{toc}{subsubsection}{\nameref{f12}}
	Hat der Nutzer die Generierung von einfachen ungerichteten Graphen gewählt, so kann er die folgenden Einstellungen vornehmen:
	\begin{enumerate}[i)]
		\item{Die Anzahl von Knoten $n$ der zu generierenden Graphen kann festgelegt werden. Es gilt $1 \leq n \leq 1000$.}
		\item{Der minimale und maximale Knotengrad $\delta_{min}$ und $\Delta_{max}$ der zu generierenden Graphen kann festgelegt werden. Für einen beliebigen generierten Graphen $G$ gilt dann $$0 \leq \delta_{min} \leq \delta(G) \leq \Delta(G) \leq \Delta_{max} \leq n-1.$$}
		\item[iii)*]{Die folgenden Grapheigenschaften können (falls gewünscht) bei der Generierung ausgeschlossen oder forciert werden:
			\begin{enumerate}[--]
				\item{Zusammenhang}
				\item{Baum}
				\item{Bipartition}
				\item{Planarität}
				%\item{Intervallgraph / Chordalität}
			\end{enumerate}
		}
	\end{enumerate}
	
	\subsubsection*{/F13/ Einstellungen für Hypergraphen} \label{f13} \addcontentsline{toc}{subsubsection}{\nameref{f13}}
	Hat der Nutzer die Generierung von einfachen Hypergraphen gewählt, so kann er die folgenden Einstellungen vornehmen:
	\begin{enumerate}[i)]
		\item{Die Anzahl von Knoten $n$ der zu generierenden Graphen kann festgelegt werden. Es gilt $1 \leq n \leq 1000$.}
		\item{Der minimale und maximale Knotengrad $\delta_{min}$ und $\Delta_{max}$ der zu generierenden Graphen kann festgelegt werden. Für einen beliebigen generierten Graphen $G$ gilt dann $$0 \leq \delta_{min} \leq \delta(G) \leq \Delta(G) \leq \Delta_{max} \leq n-1.$$}
		\item[iii)*]{Es kann (falls gewünscht) die minimale und maximale Kardinalität $k_{min}$ und $k_{max}$ der Hyperkanten festgelegt werden. Für einen beliebigen generierten Hypergraph $G$ und eine Hyperkante $e \in E(G)$ gilt dann $$2 \leq k_{min} \leq \# e \leq k_{max} \leq n.$$ Insbesondere lässt sich die Generierung über $k_{min} = k_{max} =: k$ auch auf $k$-uniforme Hypergraphen beschränken.}
	\end{enumerate}
	
	\subsubsection*{/F14/ Generierung von Graphen mit unterschiedlichen Einstellungen} \label{f14} \addcontentsline{toc}{subsubsection}{\nameref{f14}}
	Der Nutzer hat die Möglichkeit mehrere voneinander unabhängige Datenmengen zu generieren. Dies ermöglicht den direkten Vergleich zwischen Graphen, die mit unterschiedlichen Einstellungen generiert wurden. Zudem ist der Nutzer so in der Lage an mehreren offenen Problemen zeitgleich zu arbeiten.
	
	
	\newpage
	
	\subsection*{/F20/ Anwendung von Heuristiken} \label{f20} \addcontentsline{toc}{subsection}{\nameref{f20}}
	
	\subsubsection*{/F21/ Liste von Heuristiken} \label{f21} \addcontentsline{toc}{subsubsection}{\nameref{f21}}
	Es kann eine Liste von Heuristiken bestimmt werden, die auf jeden der generierten Graphen angewandt werden. Die Liste obliegt den folgenden Einschränkungen:
	\begin{enumerate}[i)]
		\item{Die möglichen Heuristiken sind abhängig von dem generierten Graphentyp.}
		\item{Dieselbe Heurisitk kann mit unterschiedlichen Einstellungen mehrfach in der Liste vorkommen, nicht jedoch zweimal mit derselben Einstellung.}
		\item{Die Bestätigung der Änderungen an der Liste bewirkt eine Neuberechnung aller neuen oder veränderten Heuristiken auf allen generierten Graphen, nicht jedoch die Neuberechnung von bereits angewandten und unverändert gebliebenen Heuristiken.}
	\end{enumerate}
	
	\subsubsection*{/F22/* Ergänzung neuer Heurisitiken} \label{f22} \addcontentsline{toc}{subsubsection}{\nameref{f22}}
	Es können neue Heuristiken als Plugins hinzugefügt werden. Die Erkennung der Plugins geschieht zum Programmstart und ist während der Laufzeit nicht mehr möglich.
	
	
	\newpage
	
	\subsection*{/F30/ Modifikation von Graphen} \label{f30} \addcontentsline{toc}{subsection}{\nameref{f30}}
	\subsubsection*{/F31/ Modifikation der einfachen Graphen} \label{f31} \addcontentsline{toc}{subsubsection}{\nameref{f31}}
	Das Programm bietet die Möglichkeit die Graphen in der folgenden Art und Weise zu modifizieren:
	\begin{enumerate}[i)]
		\item{Es können Knoten hinzugefügt werden.}
		\item{Kanten zwischen zwei bestehenden und noch nicht adjazenten Knoten können hinzugefügt werden.}
		\item{Jeder Knoten $v$ kann gelöscht werden. Alle zu $v$ inzidenten Kanten werden automatisch ebenfalls gelöscht.}
		\item{Der Nutzer kann Kanten löschen.}
		\item{Knoten können kontrahiert werden. Auftretende Mehrfachkanten werden automatisch zu einfachen Kanten reduziert. Auftretende Schleifen werden gelöscht.}
		\item{Jeder Knoten $v$ kann dupliziert werden, d.h. es wird ein neuer Knoten $v$ mit derselben Nachbarschaft wie $v$ hinzugefügt.}
		\item{Die Reihenfolge der Knoten kann verändert werden.}
	\end{enumerate}
	
	Eine beliebige Auswahl von $n$ Knoten kann auf die folgenden Graphen ergänzt werden:
	\begin{enumerate}[i)]
		\item{\textbf{Leerer Graph} $E_n$: Alle Kanten zwischen den ausgewählten Knoten werden gelöscht.}
		\item{\textbf{Pfad} $P_n$: In Reihenfolge der Auswahl werden zwischen aufeinanderfolgenden und nichtadjazenten Knoten Kanten hinzugefügt. Der erste und der letzte Knoten werden nicht explizit durch eine Kante verbunden. Wenn sie jedoch bereits adjazent sind, wird die bestehende Kante nicht gelöscht.}
		\item{\textbf{Kreis} $C_n$: Die Knoten werden wie beim Pfad in der Reihenfolge ihrer Auswahl verbunden mit dem Unterschied, dass auch der erste und letzte Knoten explizit verbunden werden.}
		\item{\textbf{Clique} $K_n$: Je zwei Knoten aus der Auswahl, die nicht bereits adjazent sind, werden durch eine neue Kante verbunden.}
	\end{enumerate}
	Es wird sichergestellt, dass der resultierende Graph auch wieder ein einfacher ungerichteter Graph ist.
	
	\subsubsection*{/F32/ Modifikation der Hypergraphen} \label{f32} \addcontentsline{toc}{subsubsection}{\nameref{f32}}
	Hypergraphen können wie folgt modifiziert werden:
	\begin{enumerate}[i)]
		\item{Es können Knoten hinzugefügt werden}
		\item{Durch Auswahl von mehr als einem Knoten kann eine Hyperkante hinzugefügt werden, wenn der Hypergraph keine Hyperkante besitzt, die mehr als einen der ausgewählten Knoten enthält.}
		\item{Jeder Knoten kann gelöscht werden. Dabei werden alle Hyperkanten, die diesen Knoten enthalten gelöscht.}
		\item{Jede Hyperkante kann gelöscht werden.}
		\item{Die Reihenfolge der Knoten kann verändert werden.}
	\end{enumerate}
	Es wird sichergestellt, dass der resultierende Hypergraph auch wieder einfach ist.
	
	\subsubsection*{/F33/ Manuelle Erstellung von Graphen und Hypergraphen} \label{f33} \addcontentsline{toc}{subsubsection}{\nameref{f33}}
	Die in /F31/ und /F32/ erwähnten Modifikationen implizieren die Möglichkeit Graphen von Hand im Programm einzutragen. Der Typ des Graphen wird durch die Auswahl in /F11/ festgelegt.
	\newpage
	
	\subsection*{/F40/ Ausgabe über eine graphischer Benutzeroberfläche} \label{f40} \addcontentsline{toc}{subsection}{\nameref{f40}}
	Die graphische Benutzeroberfläche gliedert sich im wesentlichen in die folgenden Bereiche:
	
	\subsubsection*{/F41/ Graphgenerierung} \label{f51} \addcontentsline{toc}{subsubsection}{\nameref{f51}}
	In diesem Fenster können alle Einstellungen aus /F10/ für die zu generierenden Graphen vorgenommen werden. Nach Bestätigung durch den Nutzer werden die Graphen unter Berücksichtigung dieser Einstellungen generiert.
	
	\subsubsection*{/F42/ Preview} \label{f42} \addcontentsline{toc}{subsubsection}{\nameref{f42}}
	Alle generierten Graphen werden in einer Übersicht dargestellt. Es ist ersichtlich, wie weit die Generierung fortgeschritten ist. Graphen, die durch Modifikation (siehe /F30/) auseinander hervorgegangen sind, werden als Gruppe angezeigt.
	
	~\newline
	\textbf{/F42.1/ Auswahl und Anwenden der Heuristiken}
	
	Der Nutzer kann Algorithmen auswählen, Einstellungen an ihnen vornehmen und sie in der Liste der auf die Graphen anzuwendenden Heuristiken speichern. Heuristiken können auch wieder aus der Liste entfernt werden. 
	
	Wie in /F21/ angegeben führt eine Veränderung der Liste zu einer Berechnung der neu hinzugekommenen oder veränderten Heuristiken auf allen generierten Graphen. Ferner werden die Heuristiken der Liste automatisch auf jeden neu generierten Graph angewandt.
	Es ist ersichtlich, ob auf einen Graphen noch nicht alle Heuristiken angewandt wurden bzw. ob im Moment eine Heuristik auf ihm berechnet wird.
	
	~\newline
	\textbf{/F42.2/ Filtern der angezeigten Graphen}
	
	Die Reihenfolge der Graphen in der Preview können
	\begin{enumerate}[i)]
		\item{nach Reihenfolge der Generierung}
		\item{nach Geschwindigkeit einer auszuwählenden Heuristik der Liste}
		\item{nach der Gesamtgeschwindigkeit aller Heuristiken der Liste}
	\end{enumerate}
	jeweils aufsteigend oder absteigend sortiert werden.
	Gruppierte Graphen, die z.B. durch Modifikation auseinander hervorgegangen sind, werden nach dem Durchschnitt des Sortierungsparameters einsortiert.
	
	Es kann für jede Heuristik ausgewählt werden, ob
	\begin{enumerate}[i)]
		\item{alle Graphen}
		\item{nur die Graphen, für die die Heuristik erfolgreich terminiert ist}
		\item{nur die Graphen, für die die Heuristik nicht erfolgreich war}
	\end{enumerate}
	angezeigt werden sollen. Ferner kann die Anzahl der angezeigten Graphen durch den Nutzer beschränkt werden.
	
	Dieser Filterungsprozess hat rein visuelle Auswirkungen und bewirkt \textbf{nicht} den Verlust der aussortierten Graphen.
	
	~\newpage
	\subsubsection*{/F43/ Detailansicht} \label{f43} \addcontentsline{toc}{subsubsection}{\nameref{f43}}
	
	Die Detailansicht bietet dem Nutzer die Möglichkeit, sich die Arbeitsweise und Ergebnisse der Heuristiken auf einem von ihm ausgewählten Graph genauer anzuschauen. Sowohl Graphen als auch Hypergraphen können in den folgenden Arten präsentiert werden:
	\begin{enumerate}[i)]
		\item{In der graphischen Repräsentation sind alle Knoten im Uhrzeigersinn gemäß ihrer Reihenfolge im Kreis angeordnet. Die Kanten sind einfache Liniensegmente von Knoten zu Knoten, während die Hyperkanten als konvexe Polygone mit den zugehörigen Knoten als Eckpunkten dargestellt werden.}
		\item{In einer tabellarischen Repräsentation}
	\end{enumerate}
	
	Der Nutzer kann aus der in /F42/ erstellten Liste eine beliebige Heuristik auswählen, deren Ergebnis dann in geeigneter Weise (z.B. durch Färben der Kanten) angezeigt wird. Ferner besteht die Möglichkeit die Heuristik neu auszuführen, um ihre Arbeitsweise wahlweise live oder schrittweise zu begutachten. Ein Eingriff in die Arbeitsweise der Heuristik ist jedoch \textbf{nicht} möglich.
	
	Der Nutzer kann zudem lokal weitere Heuristiken auf den Graphen anwenden, die nicht in der globalen Liste aus /F42/ sind. Das ermöglicht die genauere Untersuchung eines einzelnen Graphen.
	
	\subsubsection*{/F44/ Grapheditor} \label{f44} \addcontentsline{toc}{subsubsection}{\nameref{f44}}
	Der Grapheditor bietet dem Nutzer alle in /F30/ spezifierten Möglichkeiten um Graphen zu modifizieren oder zu erstellen.
	
	
	~\newpage
	\subsection*{/F50/ Heuristiken für das Total Coloring Conjecture} \label{f50} \addcontentsline{toc}{subsection}{\nameref{f50}}
	Die folgenden Heuristiken sind implementiert:
	\begin{enumerate}[i)]
		\item{\textbf{Greedy}: Zunächst werden die Knoten möglichst gleichmäßig koloriert. Anschließend werden Knoten für Knoten alle Kanten koloriert.}
		\item{\textbf{Greedy + One}: Wie Greedy, jedoch mit der folgenden Einschränkung: Gibt es eine unkolorierte Kante im Graph, die genau eine freie Farbe hat, so wird diese vorrangig koloriert.}
		\item{\textbf{Greedy + Few}: Wie Greedy mit der Eigenschaft, dass statt Knoten für Knoten stets die Kanten mit der minimalen Anzahl von freien Farben koloriert werden.}
		\item{\textbf{Greedy + Set}: Wie Greedy mit der folgenden Policy: Es wird unter allen Mengen von Kanten, bei denen alle Kanten inzident zu einem gemeinsamen Knoten sind, eine mit minimaler Flexibilität koloriert.}
		\item{\textbf{Greedy + Connected}: Wie Greedy + Set mit der Verallgemeinerung, dass die Menge von Kanten nicht inzident zu einem gemeinsamen Knoten, sondern lediglich zusammenhängend sein muss. Die maximale Kardinalität einer solchen Teilmenge ist durch den Nutzer einstellbar.}
		\item[vi)*]{\textbf{Mixed Greedy}: Knoten und Kanten sind gleichwertig und werden nicht separat koloriert.}
		\item[vii)*]{\textbf{Line Greedy}: Wie die Greedy Familie, nur Vertauschen der Rolle von Knoten und Kanten.}
	\end{enumerate}
	Die Heuristiken berechnen eine möglichst gleichmäßige Farbverteilung. Dabei ist die Gewichtung des Einflusses von Knoten und Kanten für die freien Farben durch den Nutzer einstellbar.
	
	Es wird abgebrochen, sobald die Bedingungen des Total Coloring Conjectures verletzt sind, oder wenn eine korrekte Totalfärbung berechnet wurde. 
	
	Die Heuristiken sind deterministisch. Das bedeutet, dass eine Heuristik mehrfach angewandt auf denselben Graph mit denselben Einstellungen das gleiche Ergebnis liefert.
	
	\subsection*{/F60/ Heuristiken für das Erdös Faber Lovasz Conjecture} \label{f60} \addcontentsline{toc}{subsection}{\nameref{f60}}
	Die folgenden Heuristiken sind implementiert:
	\begin{enumerate}[i)]
		\item{\textbf{Greedy}: Es werden Knoten für Knoten alle Hyperkanten koloriert.}
		\item{\textbf{Greedy + One}: Wie Greedy, jedoch mit der folgenden Einschränkung: Gibt es eine unkolorierte Hyperkante im Hypergraph, die genau eine freie Farbe hat, so wird diese vorrangig koloriert.}
		\item{\textbf{Greedy + Few}: Wie Greedy mit der Eigenschaft, dass statt Knoten für Knoten stets die Hyperkanten mit der minimalen Anzahl von freien Farben koloriert werden.}
		\item{\textbf{Greedy + Set}: Wie Greedy mit der folgenden Policy: Es wird unter allen Mengen von Hyperkanten, bei denen alle Kanten inzident zu einem gemeinsamen Knoten sind, eine mit minimaler Flexibilität koloriert.}
		\item{\textbf{Greedy + Connected}: Wie Greedy + Set mit der Verallgemeinerung, dass die Menge von Hyperkanten nicht inzident zu einem gemeinsamen Knoten, sondern lediglich zusammenhängend sein muss. Die maximale Kardinalität einer solchen Teilmenge ist durch den Nutzer einstellbar.}
	\end{enumerate}
	
	Die Heuristiken berechnen eine möglichst gleichmäßige Farbverteilung.	
	Es wird abgebrochen, sobald die Bedingungen des Erdös Faber Lovasz Conjectures verletzt sind, oder wenn eine korrekte Färbung berechnet wurde. 
	
	Die Heuristiken sind deterministisch. Das bedeutet, dass eine Heuristik mehrfach angewandt auf denselben Graph mit denselben Einstellungen das gleiche Ergebnis liefert.
	
	
	~\newpage
	\subsection*{/F70/ Speichern und Laden} \label{f70} \addcontentsline{toc}{subsection}{\nameref{f70}}
	
	\subsubsection*{/F71/ Graphen} \label{f71} \addcontentsline{toc}{subsubsection}{\nameref{f71}}
	Der Nutzer kann eine Auswahl oder alle generierten Graphen speichern. Für jeden Graph werden die Ergebnisse aller darauf berechneten Heuristiken zusammen mit den Einstellungen der Heuristik gespeichert.
	
	Gespeicherte Graphen können wieder geladen werden. Sie werden als von möglicherweise bereits generierten Graphen unabhängige Datenmenge in das Programm eingefügt. Ergebnisse von auf ihnen berechneten Heuristiken werden übernommen. Ist eine Heuristik eigentlich nicht auf den Graphen anzuwenden, so wird ihr Ergebnis in der lokalen Liste von Heuristiken des Graphen gespeichert.
		
	\subsubsection*{/F72/ Heuristiken} \label{f72} \addcontentsline{toc}{subsubsection}{\nameref{f72}}
	Die Liste der eingestellten Heuristiken kann gespeichert werden. Die Heuristiken können auch wieder geladen werden, wenn sie auf den in /F11/ eingestellten Graphentyp anwendbar sind.
	
	~\newpage
	\section{Nichtfunktionale Anforderungen}
	\subsection*{/NF10/ Zuverlässigkeit} \label{nf10} \addcontentsline{toc}{subsection}{\nameref{nf10}}
	Eine Benutzung gemäß der funktionalen Anforderungen führt zu keinen Komplikationen. Die Generierung von Graphen erfolgt nach den eingestellten Kriterien. Die implementierten Heuristiken verhalten sich wie in /F50/ und /F60/ spezifiziert.
	
	\subsection*{/NF20/ Benutzbarkeit} \label{nf20} \addcontentsline{toc}{subsection}{\nameref{nf20}}
	Die Benutzung des Programms erfolgt über die graphische Benutzeroberfläche. Sie ist intuitiv gestaltet, sodass für die Benutzung keine Schulung nötig ist. Die Eingabe von ungültigen Daten wird dem Nutzer mitgeteilt und führt insbesondere nicht zu einem Absturz.
	
	\subsection*{/NF30/ Effizienz} \label{nf30} \addcontentsline{toc}{subsection}{\nameref{nf30}}
	Die Generierung der Graphen erfolgt abhängig von den gewählten Einstellungen in angemessener Zeit.
	
	Über die Effizienz der Heuristiken selbst wird \textbf{keine} Angabe gemacht. Die Laufzeit der Heuristiken wird jedoch durch andere Funktionen des Programms nicht übermäßig beeinflusst. Parallelisierung erlaubt Generierung und Anwendung von Heuristiken gleichzeitig.
	
	\subsection*{/NF40/* Erweiterbarkeit} \label{nf40} \addcontentsline{toc}{subsection}{\nameref{nf40}}
	Das Programm bietet mit der in /F22/ erwähnten Pluginarchitektur und insgesamt modularen Programmarchitektur die Erweiterung um neue Heuristiken.
	
	
	~\newpage
	\section{Testfälle}
	\subsection*{/T10/ Generierung und Modifikation} \label{t10} \addcontentsline{toc}{subsection}{\nameref{t10}}
	\begin{enumerate}[--]
		\item{Die Einstellungen bei der Graphengenerierung (z.B. Graphentyp, minimaler + maximaler Knotengrad etc.) werden bei der Generierung berücksichtigt}
		\item{Nach Bestätigung durch den User werden die Graphen generiert}
		\item{Graphen werden vollständig importiert}
		\item{Abbrechen der Generierung}
		\item{Eingabe des Graphen per Hand}
	\end{enumerate}
	
	\subsection*{/T20/ Heuristiken} \label{t20} \addcontentsline{toc}{subsection}{\nameref{t20}}
	\begin{enumerate}[--]
		\item{Heuristiken in der Liste entsprechen den durch den Nutzer ausgewählten Heuristiken}
		\item{Anwendung der Heuristiken auf die Graphen gemäß Nutzerauswahl}
		\item{Fehlverhalten der Heuristik}
	\end{enumerate}
	
	\subsection*{/T30/ Darstellung von Graphen} \label{t30} \addcontentsline{toc}{subsection}{\nameref{t30}}
	\begin{enumerate}[--]
		\item{Filtern und Sortieren der Graphen nach durch den Nutzer gegebenen Kriterien}
		\item{Ausgabe der Graphen in gewünschter Darstellungsform}
		\item{Darstellung eines Graphen in jeweiliger Darstellungsform ist eindeutig}
		\item{Modifikation von Graphen führt zu Gruppierung}
	\end{enumerate}
	
	\subsection*{/T40/ Datenkonsistenzen} \label{t40} \addcontentsline{toc}{subsection}{\nameref{t40}}
	\begin{enumerate}[--]
		\item{Für einfache ungerichtete Graphen gilt: $$\#V(G) \cdot \delta_{min} \leq \#V(G) \cdot \delta(G) \leq \#E(G) \cdot 2 \leq \#V(G) \cdot \Delta(G) \leq \#V(G) \cdot \Delta_{max}$$}
		\item{Falls $\delta_{min} = \Delta_{max} = n-1$, so wird nur genau ein Graph generiert}
		\item{Generierte Graphen sind entweder einfache ungerichtete Graphen oder einfache Hypergraphen}
		\item{Die erhobenen Statistiken sind korrekt}
	\end{enumerate}
	
	
	~\newpage
	\section{Produktdaten}
	\subsection*{/D10/ Graphen} \label{d10} \addcontentsline{toc}{subsection}{\nameref{d10}}
	Für die Graphenstruktur werden die folgenden Daten gespeichert:
	\begin{enumerate}[--]
		\item{Anzahl der Knoten}
		\item{Liste der (Hyper-) Kanten}
		\item{Minimale, maximaler und durchschnittlicher Knotengrad}
		\item[--]{Die in /F12/* erkannten Grapheigenschaften}
	\end{enumerate}
	
	Für jede auf den Graphen angewandte Heuristik werden die folgenden Daten gespeichert:
	\begin{enumerate}[--]
		\item{Name der Heuristik}
		\item{Einstellungen der Heuristik}
		\item{Ergebnis der Heuristik, d.h. z.B. die Färbung zur Zeit des Abbruchs}
		\item{Laufzeit der Heuristik}
	\end{enumerate}
	
	\subsection*{/D20/ Heuristiken} \label{d20} \addcontentsline{toc}{subsection}{\nameref{d20}}
	Für Heuristiken werden der Name sowie die Einstellungen gespeichert.
	
	~\newpage
	\section{Graphische Benutzeroberfläche}
	Es folgen frühe Vorschläge für die Benutzeroberfläche. Alle angegebenen Werte sind exemplarisch, insbesondere wurden dargestellte Graphen nicht generiert.
	
	
	
	\subsection{Graphgenerierung}
	\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{images/gui/generate}
		\caption{Das Fenster für die Graphgenerierung}
	\end{figure}
	
	\FloatBarrier
	
	\begin{enumerate}[(1)]
		\item{Auswahl des zu generierenden Graphentyps}
		\item{Allgemeine Einstellungen}
		\item{Weitere Einstellungen wie in /F12/iii)* oder /F13/iii)* erwähnt}
		\item{Laden von bereits generierten Graphen}
		\item{Öffnet den Grapheneditor um Graphen per Hand einzugeben}
		\item{Generiert Graphen gemäß den getroffenen Einstellungen}
	\end{enumerate}
	
	
	
	
	~\newpage
	\subsection{Preview}
	~\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{images/gui/preview}
		\caption{Das Preview-Fenster}
	\end{figure}
	
	\FloatBarrier
	
	\begin{enumerate}[(1)]
		\item{Liste der Heuristiken, die auf die generierten Graphen angewandt werden}
		\item{Ermöglicht das Hinzufügen von Heuristiken zu der Liste}
		\item{Bestätigt Liste und führt alle neu hinzugekommenen Heuristiken aus}
		\item{Liste aller bereits generierten Graphen}
		\item{Filter- und Darstellungsoptionen für die Liste der Graphen}
	\end{enumerate}
	
	
	~\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{images/gui/settings}
		\caption{Hinzufügen neuer Heuristiken}
	\end{figure}
	
	\FloatBarrier
	
	\begin{enumerate}[(1)]
		\item{Mögliche Heuristiken, die zur Auswahl stehen}
		\item{Heuristikspezifische Einstellungen}
		\item{Fügt Heuristik mit getroffenen Einstellungen zur Liste hinzu}
		\item{Verwirft die getroffenen Änderungen und kehrt zurück zur Preview}
		\item{Sichert die getroffenen Änderungen und kehrt zurück zur Preview}
	\end{enumerate}
	
	
	~\newpage
	
	~\begin{figure}[!h]
		\centering
		\includegraphics{images/gui/filter}
		\caption{Filteroptionen}
	\end{figure}
	
	\FloatBarrier
	
	\begin{enumerate}[(1)]
		\item{Auswahlmöglichkeit pro Heuristik}
		\item{Sortierungsoption}
	\end{enumerate}
	
	~\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{images/gui/statistic}
		\caption{Statistiken zur Laufzeit und Erfolgsrate der Statistiken}
	\end{figure}
	
	
	
	%~\newpage
	\subsection{Detailansicht}
	~\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{images/gui/detail}
		\caption{Die Detailansicht für die Graphen}
	\end{figure}
	
	\FloatBarrier
	
	\begin{enumerate}[(1)]
		\item{Liste der Heuristiken, die auf alle Graphen der Preview angewendet wurden}
		\item{Lokale Liste von Heuristiken, die nur auf den ausgewählten Graph angewandt werden}
		\item{Auswahl der Darstellung (graphisch oder tabellarisch)}
		\item{Ermöglicht Beobachtung der Arbeitsweise der ausgewählten Heuristik}
		\item{Speichern des Graphen}
		\item{Öffnet den Grapheditor zur Modifikation des Graphen}
		\item{Informationen über den Graphen (z.B. $\delta (G), \Delta (G), \# E(G)$)}
		\item{Darstellung des Graphen mit Ergebnis der ausgewählten Heuristik}
	\end{enumerate}
	
	
	
	
	~\newpage
	\subsection{Grapheditor}
	~\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{images/gui/editor}
		\caption{Die Detailansicht für die Graphen}
	\end{figure}
	
	\FloatBarrier
	
	\begin{enumerate}[(1)]
		\item{Optionen zur Modifikation des Graphen}
		\item{Letzte Änderung rückgängig machen}
		\item{Verwerfen / Bestätigen der Modifikation}
	\end{enumerate}
	
	~\newpage
	\section{Systemmodelle}
	\subsection{Szenarien}
	
	\subsubsection{Generierung von Graphen}
	\textbf{Vorbedingung}: keine
	
	\textbf{Nachbedingung} Es wurden Graphen mit durch den Nutzer spezifizierten Eigenschaften generiert
	
	\textbf{Ablauf}:
	\begin{enumerate}[1)]
		\item{Der Nutzer wählt den gewünschten Graphentyp und die gewünschten Grapheigenschaften aus und bestätigt seine Auswahl.}
		\item{Das Programm generiert anhand der Eigenschaften zufällige Graphen und gibt sie in der Preview graphisch aus. Es können jederzeit neue Graphen generiert werden. Diese werden dann in einer seperaten Preview ausgegeben.}
	\end{enumerate}
	
	\textbf{Schema}:
	~\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{images/workflow/graph_generation}
	\end{figure}
	
	
	\FloatBarrier
	~\newpage
	\subsubsection{Graphen von Hand erstellen}
	\textbf{Vorbedingung}: keine
	
	\textbf{Nachbedingung} Der erstellte Graph wird in Preview geladen.
	
	\textbf{Ablauf}:
	\begin{enumerate}[1)]
		\item{Der Nutzer wählt die >>Von Hand erstellen<< Option aus. Der Grapheditor wird geöffnet.}
		\item{Es kann mithilfe von Tools ein Graph erstellt werden.}
		\item{Sobald der Nutzer >>OK<< betätigt, wird der Graph hinten an die Graphenliste in der Preview geladen.}
	\end{enumerate}
	
	\textbf{Schema}:
	~\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{images/workflow/graph_drawing}
	\end{figure}
	
	
	\FloatBarrier
	~\newpage
	\subsubsection{Importieren von Graphen}
	\textbf{Vorbedingung}: Es wird eine korrekt kodierte Datei ausgelesen
	
	\textbf{Nachbedingung} (Erfolg): Der Graph / die Graphen werden aus der Datei gelesen und in die Liste der Graphen aufgenommen.
	
	\textbf{Nachbedingung} (Misserfolg): Es erscheint eine aussagekräftige Fehlermeldung.
	
	\textbf{Ablauf}:
	\begin{enumerate}[1)]
		\item{Der Nutzer wählt den Pfad zu der Datei aus.}
		\item{Das Programm liest die Datei aus.}
		\item{
			\begin{enumerate}[a)]
				\item{Bei Erfolg werden die Graphen in die Liste der Graphen aufgenommen.}
				\item{Bei Misserfolg wird der Grund des Fehlers angezeigt, falls er ermittelt werden kann.}
			\end{enumerate}
		}
	\end{enumerate}
	
	
	\FloatBarrier
	~\newpage
	\subsubsection{Detailansicht}
	\textbf{Vorbedingung}: Es muss einen generierten Graph geben.
	
	\textbf{Nachbedingung} Keine
	
	\textbf{Ablauf}:
	In der Detailansicht hat der Nutzer die folgenden Möglichkeiten:
	\begin{enumerate}[1)]
		\item{Lokale Heuristiken hinzufügen}
		\item{Graphen auf der Festplatte speichern}
		\item{Ansicht ändern: Graphisch / Tabellarisch}
		\item{Eine Heuristik im Step-by-Step-Modus ablaufen lassen}
		\item{Einen neuen Graphen aus dem alten erstellen. Nach Auswahl von >>Graphen von Hand bearbeiten<< öffnet sich der Grapheditor.}
		\item{Zwischen den Graphen in der Preview wechseln, die in der Detailansicht angezeigt werden sollen}
		\item{Informationen über Eigenschaften des Graphen einlesen}
	\end{enumerate}
	
	\textbf{Schema}: Siehe Schema zu >>Graphen von Hand bearbeiten<<
	
	
	\subsubsection{Graphen von Hand bearbeiten}
	\textbf{Vorbedingung}: Es gibt einen Graph.
	
	\textbf{Nachbedingung}: Falls Änderungen am Graphen vorgenommen wurden, so wird die geänderte Version direkt neben dem ursprünglichen Graphen in der Preview gespeichert und die Zugehörigkeit mit einer Schraffierung gekennzeichnet.
	
	\textbf{Ablauf}:
	\begin{enumerate}[1)]
		\item{Der Nutzer öffnet einen Graphen in der Detailansicht. Er drückt auf >>Bearbeiten<<.}
		\item{Graph wird im Editor geöffnet}
		\item{Der Nutzer kann mithilfe von Tools den Graphen bearbeiten}
		\item{Sobald der Nutzer auf >>OK<< drückt, wird der modifizierte Graph in die Detailansicht geladen}
	\end{enumerate}
	
	\textbf{Schema}: siehe nächste Seite
	~\begin{figure}[!h]
		\centering
		%\hspace*{-3cm}
		\includegraphics[angle=90, width=0.8\textwidth]{images/workflow/detail2}
	\end{figure}
	
	\FloatBarrier
	\subsubsection{Allgemeiner Workflow}
	~\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{images/workflow/heuristic_selection}
	\end{figure}
	
	
	\FloatBarrier
	~\newpage
	\subsubsection{Heuristiken auf Graphen anwenden}
	\textbf{Vorbedingung}: Es gibt mindestens einen generierten oder geladenen Graph, auf den die Heuristik noch nicht angewandt wurde.
	
	\textbf{Nachbedingung} (Erfolg): Heuristik wurde auf den Graphen angewandt. Das Resultat war positiv.
	
	\textbf{Nachbedingung} (Misserfolg): Heuristik wurde auf den Graphen angewandt. Das Resultat war negativ.
	
	\textbf{Ablauf}:
	\begin{enumerate}[1)]
		\item{Der Nutzer wählt die anzuwendenden Heuristiken aus.}
		\item{Das Programm färbt jeden Graph mit jeder Heuristik}
		\item{
			\begin{enumerate}[a)]
				\item{Bei Erfolg speichert das Programm, dass die Heuristik auf diesem Graph erfolgreich war.}
				\item{Bei Misserfolg speichert das Programm nicht nur, dass die Heuristik auf dem Graph nicht erfolgreich war, sondern auch die Fehlerdetails und den Zustand beim Abbruch.}
			\end{enumerate}
		}
		\item{Das Programm sucht den nächsten Graph, der die Vorbedingung erfüllt oder der Nutzer bricht die Anwendung der Heuristiken ab.}
	\end{enumerate}
	
	\textbf{Schema}:
	~\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{images/workflow/heuristic_apply}
	\end{figure}
	
	
	
	
	~\newpage
	\subsubsection{Filtern der Graphen}
	\textbf{Vorbedingung}: Es gibt mindestens einen Graph, auf den mindestens eine Heuristik angewandt wurde.
	
	\textbf{Nachbedingung}: Die Graphen werden gemäß dem eingestellten Filter sortiert angezeigt.
	
	\textbf{Ablauf}:
	\begin{enumerate}[1)]
		\item{Der Nutzer wählt Filter und Sortierung.}
		\item{Das Programm filtert die Graphen, auf denen die Heuristiken berechnet wurden.}
		\item{Die Graphen werden sortiert.}
		\item{Die bereits gefilterten und sortierten Graphen werden zuerst ausgegeben, die nicht filter-/sortierbaren Graphen werden anschließend angezeigt.}
		\item{Hat eine Heuristik auf einem noch nicht gefilterten/sortierten Graph terminiert, wird dieser falls möglich in die sortierten Graphen eingefügt.}
	\end{enumerate}
	
	\textbf{Schema}:
	~\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{images/workflow/filter}
	\end{figure}
	
	
	
	\FloatBarrier
	~\newpage
	\subsubsection{Statistiken anzeigen}
	\textbf{Vorbedingung}: Es gibt mindestens einen Graph, auf den mindestens eine Heuristik angewandt wurde.
	
	\textbf{Nachbedingung}: Es werden verschiedene Statistiken angezeigt, die Informationen über Heuristiken und Graphen beinhalten.
	
	\textbf{Ablauf}:
	\begin{enumerate}[1)]
		\item{Während der Anwendung der Heurstiken sammelt das Programm Daten über die Graphen, sowie Effizienz und Erfolg der Heuristiken.}
		\item{Durch Nutzerinteraktion wird das Statistik-Fenster geöffnet.}
		\item{Das Programm liest die gesammelten Daten aus und stellt sie graphisch dar.}
	\end{enumerate}
	
	
	\subsubsection{Graphen speichern}
	\textbf{Vorbedingung}: Es gibt mindestens einen Graph in der Preview.
	
	\textbf{Nachbedingung}: Graphen werden korrekt in einer Datei auf der Festplatte gespeichert.
	
	\textbf{Ablauf}:
	\begin{enumerate}[1)]
		\item{Der Nutzer wählt die Optionen >>Graphen<< $\rightarrow$ >>Graphen speichern<<.}
		\item{Anschließend wählt er die zu speichernden Graphen aus und bestätigt.}
		\item{Die Graphen werden in einer Datei kodiert und auf der Festplatte gespeichert.}
	\end{enumerate}
	
	
	\subsubsection{Heuristiken speichern}
	\textbf{Vorbedingung}: Es gibt mindestens eine Heuristik in der Liste der Heuristiken.
	
	\textbf{Nachbedingung}: Heuristiken werden korrekt in einer Datei auf der Festplatte gespeichert.
	
	\textbf{Ablauf}:
	\begin{enumerate}[1)]
		\item{Der Nutzer wählt die Optionen >>Hilfe \& Sonstiges<< $\rightarrow$ >>Heuristiken speichern<<.}
		\item{Anschließend wählt er die zu speichernden Heuristiken aus und bestätigt.}
		\item{Die Heuristiken werden in einer Datei kodiert und auf der Festplatte gespeichert.}
	\end{enumerate}
	
	
	~\newpage
	\subsubsection{Heuristiken laden}
	\textbf{Vorbedingung}: Die einzulesende Datei ist korrekt und es wurde mindestens ein Graph erstellt.
	
	\textbf{Nachbedingung} (Erfolg): Heuristikeinstellungen werden aus der Datei gelesen und in die Heuristikauswahl übernommen.
	
	\textbf{Nachbedingung} (Misserfolg): Es erscheint eine aussagekräftige Fehlermeldung.
	
	\textbf{Ablauf}:
	\begin{enumerate}[1)]
		\item{Der Nutzer wählt die Optionen >>Hilfe \& Sonstiges<< $\rightarrow$ >>Heuristiken importieren<<.}
		\item{
			\begin{enumerate}[a)]
				\item{Falls der Nutzer die Preview offen hat, liest das Programm die Datei aus und importiert die Heuristiken in die globale Liste.}
				\item{Falls der Nutzer die Detailansicht offen hat, liest das Programm die Datei aus und importiert die Heuristiken in die lokale Liste.}
			\end{enumerate}
		}
		\item{Bei Misserfolg wird der Grund des Fehlers angezeigt, falls er ermittelt werden kann.}
	\end{enumerate}

	\subsubsection{* Einfügen eines Heuristik-Plugins}
	\textbf{Vorbedingung}: Das Plugin ist korrekt geschrieben und compiliert.
	
	\textbf{Nachbedingung} (Erfolg): Das Plugin wird in das Programm übernommen und seine Heuristiken werden korrekt erkannt.
	
	\textbf{Nachbedingung} (Misserfolg): Es erscheint eine aussagekräftige Fehlermeldung.
	
	\textbf{Ablauf}:
	\begin{enumerate}[1)]
		\item{Der Nutzer informiert sich unter >>Hilfe \& Sonstiges<< $\rightarrow$ >>Heuristik-Plugins<< über das Einfügen von Heuristik-Plugins.}
		\item{Das Plugin wird in dem angegebenen Ordner abgelegt.}
		\item{Beim nächsten Programmstart werden alle Plugins aus dem Ordner geladen.}
		\item{
			\begin{enumerate}[a)]
				\item{Bei Erfolg erscheinen die Heuristiken des hinzugefügten Plugins in den auswählbaren Heuristiken.}
				\item{Bei Misserfolg wird der Grund des Fehlers angezeigt, falls er ermittelt werden kann.}
			\end{enumerate}
		}
	\end{enumerate}

	~\newpage
	\subsection{Anwendungsfälle}
	
	~\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{images/usecase}
	\end{figure}
	
	\FloatBarrier
	
	~\newpage
	\subsection{Durchführbarkeitsanalyse}
	\subsubsection{Technische Durchführbarkeit}
	\textbf{Hardware}
	
	Jedes Teammitglied besitzt einen modernen Rechner, der insbesondere den Kriterien der Produktumgebung entspricht.
	\newline
	
	\textbf{Software}
	
	Die erwähnten Rechner haben hauptsächlich Windows 10 als Betriebssystem. Weitere Rechner mit MacOS und Linux sind vorhanden um Plattformunabhängigkeit zu gewährleisten.
	
	Die Entwicklung des Programms erfolgt in Java. Zu diesem Zweck werden geeignete IDEs (z.B. NetBeans, IntelliJ, Eclipse) verwendet. Die graphischen Benutzeroberflächen werden mit Screenbuilder2 erstellt. Das Programm wird mithilfe von JUnit getestet, Versionskontrolle erfolgt mithilfe von Git.
	
	Dieses und folgende Spezifikationsdokumente werden mit LaTeX erstellt, Folien für Präsentationen hingegen mit PowerPoint, Keynote oder LaTeX.
	\newline
	
	\textbf{Orgware}
	
	Zur Organisation des Teams kommen GitHub, Trello und WhatsApp zum Einsatz.
	
	\subsubsection{Personelle Durchführbarkeit}
	Das Team erfüllt alle Voraussetzungen des Moduls Praxis der Softwareentwicklung, das den Rahmen für die Entwicklung dieses Projektes bildet. Es wird von fünf Informatikstudenten im dritten oder höherem Semester entwickelt. Damit verbunden sind solide fachliche Kompetenzen im Bereich der Softwareentwicklung. Die oben genannte Entwicklungsumgebung ist allen Teammitgliedern vertraut.
	
	Die Entwicklung erfolgt nach dem Wasserfallmodell und umfasst einen zeitlichen Aufwand von etwa 270 Stunden pro Teammitglied. Diese Zeit ist ausreichend für die Fertigstellung des Programms innerhalb eines Semesters.
	
	
	\subsubsection{Alternativen}
	Es ist möglich eine ausreichend große Anzahl von Graphen per Hand zu generieren und auf ihnen verschiedene Heuristiken nachzurechnen. Diese Option ist jedoch aufgrund ihrer zeitlichen Aufwändigkeit und Fehleranfälligkeit nicht praktikabel.
	
	Eine weitere Option ist die selbstständige Erweiterung von bestehender Software zur Generierung und Kolorierung von Graphen. Die folgende Software ist frei im Internet verfügbar:
	\begin{enumerate}[--]
		\item{https://github.com/CSCsw/ColPack}
		\item{http://graphstream-project.org/}
	\end{enumerate}
	
	~\newpage
	\subsubsection{Risiken}
	Neben den üblichen Problemen
	\begin{enumerate}[--]
		\item{Fehlkalkulation des Zeitaufwands}
		\item{Ausfall von Teammitgliedern (z.B. durch Krankheit)}
		\item{Missverständnisse mit dem Auftraggeber}
		\item{Technische Schwierigkeiten (z.B. Verlust von Daten)}
	\end{enumerate}
	die zu einer Verzögerung der Fertigstellung des Projektes führen können, gibt es keine nennenswerten Risiken.
	
	~\newpage
	\section{Glossar}
	
	\subsection{Mathematische Definitionen}
	
	\textbf{Graph} \hspace*{.5em} Überbegriff für alle Graphentypen, insbesondere der hier aufgeführten
	
	\hangindent=1.5cm \hangafter=1
	\textbf{einfacher ungerichteter Graph} \newline
	Tupel $G=(V,E)$ mit Knotenmenge $V$ und Kantenmenge $E \subseteq \{e \subseteq V \mid \#e = 2\}$
	
	\hangindent=1.5cm \hangafter=1
	\textbf{einfacher Hypergraph} \newline
	Tupel $G = (V,E)$ mit Knotenmenge $V$ und Hyperkantenmenge $E \subseteq \{e \subseteq V \mid \# e > 1\}$ mit der Eigenschaft, dass $\forall e,f \in E: \# e \cap f \leq 1$
	
	\hangindent=1.5cm \hangafter=1
	\textbf{$r$-uniformer Hypergraph} \newline
	Hypergraph $G = (V,E)$ mit der Eigenschaft, dass $\forall e \in E: \# e = r$
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Adjazenz von Knoten} \newline
	$x,y \in V$ mit $\exists e \in E: x,y \in E$
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Adjazenz von Kanten} \newline
	$e,f \in E$ mit $e \cap f \neq \emptyset$
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Knotenkontraktion} \newline
	Für einen einfachen ungerichteten Graph $G$ und $x \neq y \in V$ ist $G'=(V',E')$ definiert durch $V' = V \setminus \{x,y\} \cup \{v_{xy}\}$, wobei $v_{x,y} \notin V$, und $E' = E_1 \cup E_2$ mit $E_1 = \{e \in E \mid x,y \notin e\}$ und $E_2 = \{\{v, v_{x,y}\} \mid \{v,x\} \in E $ oder $ \{v,y\} \in E\}$
	
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Zusammenhängender Graph} \newline
	$\forall x,y \in V \;\exists n \in \mathbb N \;\exists e_1, ..., e_n \in E$, sodass $x \in e_1$, $y \in e_n$ und $\forall i \in \{1, ..., n-1\}: e_i \cap e_{i+1} \neq \emptyset$
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Baum} \newline
	einfacher, ungerichteter, zusammenhängender Graph mit $\# E = \#V-1$
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Bipartiter Graph} \newline
	einfacher, ungerichteter Graph mit $\exists A,B \subseteq V$, sodass $A \cap B = \emptyset$, $A \cup B = V$ und $\forall e = \{x,y\} \in E:$ \OE $\; x \in A, y \in B$
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Pfad} \newline
	Für $n \in \mathbb N$ ist $P_n = (V,E)$ mit $V = \{v_1, ..., v_n\}$ und $E = \{\{v_i, v_i+1\} \mid i = 1, ..., n-1\}$
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Kreis} \newline
	Für $n \in \mathbb N$ ist $C_n = (V,E)$ mit $V = \{v_1, ..., v_n\}$ und $E = \{\{v_i, v_i+1\} \mid i = 1, ..., n-1\} \cup \{\{v_n, v_1\}\}$
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Clique} \newline
	Für $n \in \mathbb N$ ist $K_n = (V,E)$ mit $V = \{v_1, ..., v_n\}$ und $E = \{e \subseteq V \mid \#e = 2\}$
	
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Knotenkolorierung} \newline
	$c: V \to \mathbb N$ mit $\forall x,y \in V$ mit $\exists e \in E: x,y \in e$ gilt $c(x) \neq c(y)$
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Kantenkolorierung} \newline
	$c: E \to \mathbb N$ mit $\forall e,f \in E$ mit $e \cap f \neq \emptyset$ gilt $c(e) \neq c(f)$
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Totalkolorierung} \newline
	$c: V \cup E \to \mathbb N$ mit $c \vert _V$ ist Knotenkolorierung, $c \vert_E$ ist Kantenkolorierung und $\forall v \in V, e \in E$ mit $v \in e$ gilt $c(v) \neq c(e)$
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Heuristik} \newline
	Algorithmus, der mit auf Vermutungen basierenden Methoden, versucht zu einer Lösung des Problems zu kommen. Falls eine Lösung gefunden wird, kann diese von der optimalen Lösung abweichen.
	
	\subsection{Terminologie}
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Generieren} \newline
	Erstellen von Datenmengen mit probabilistischen Methoden.
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Plugin} \newline
	Optionale Softwarekomponente, die eine bestehende Software erweitert. Sie wird oft vom Benutzer installiert und von der Hauptanwendung zur Laufzeit eingebunden. Ein Plugin ist ohne Hauptanwendung nicht lauffähig.
	
	\hangindent=1.5cm \hangafter=1
	\textbf{Speichern und Laden} \newline
	Das Programm nutzt zunächst nur den flüchtigen Arbeitsspeicher. Sollen Daten über die Laufzeit des Programms hinaus gesichert werden, so müssen diese auf die Festplatte geschrieben werden. Dieser Prozess heißt speichern. Die Umkehrung des Prozesses, d.h. das Wiedereinfügen der Daten in den Arbeitsspeicher, heißt laden.
	
	\subsection{Akronyme}
	
	\textbf{KIT} Karlsruher Institut für Technologie
	
	\textbf{IPD} Institut für Programmstrukturen und Datenorganisation
	
\end{document}